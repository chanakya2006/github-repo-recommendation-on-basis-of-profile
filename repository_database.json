{
  "repositories": [
    {
      "owner": "parulsri1616",
      "name": "rock_paper_sci",
      "url": "https://github.com/parulsri1616/rock_paper_sci",
      "description": "",
      "readme_content": "rock_paper_sci",
      "languages": {},
      "topics": [],
      "stars": 0,
      "forks": 0,
      "last_updated": "2025-02-22T13:53:30.818093"
    },
    {
      "owner": "parulsri1616",
      "name": "Guessing-game_Python",
      "url": "https://github.com/parulsri1616/Guessing-game_Python",
      "description": "",
      "readme_content": "Its a simple guessing game using python.",
      "languages": {
        "python": 1,
        "Python": 1
      },
      "topics": [
        "Python"
      ],
      "stars": 0,
      "forks": 0,
      "last_updated": "2025-02-22T13:53:31.535341"
    },
    {
      "owner": "parulsri1616",
      "name": "Heartb___",
      "url": "https://github.com/parulsri1616/Heartb___",
      "description": "",
      "readme_content": "",
      "languages": {},
      "topics": [],
      "stars": 0,
      "forks": 0,
      "last_updated": "2025-02-22T13:53:32.151817"
    },
    {
      "owner": "sinaptik-ai",
      "name": "pandas-ai",
      "url": "https://github.com/sinaptik-ai/pandas-ai",
      "description": "Chat with your database or your datalake (SQL, CSV, parquet). PandasAI makes data analysis conversational using LLMs and RAG.",
      "readme_content": "PandaAI is a Python platform that makes it easy to ask questions to your data in natural language. It helps non-technical users to interact with their data in a more natural way, and it helps technical users to save time, and effort when working with data.\n🔧 Getting started\nYou can find the full documentation for PandaAI here.\nYou can either decide to use PandaAI in your Jupyter notebooks, Streamlit apps, or use the client and server architecture from the repo.\n☁️ Using the platform\nThe library can be used alongside our powerful data platform, making end-to-end conversational data analytics possible with as little as a few lines of code.\nLoad your data, save them as a dataframe, and push them to the platform\nimport pandasai as pai\n\npai.api_key.set(\"your-pai-api-key\")\n\nfile = pai.read_csv(\"./filepath.csv\")\n\ndataset = pai.create(path=\"your-organization/dataset-name\",\n    df=file,\n    name=\"dataset-name\",\n    description=\"dataset-description\")\n\ndataset.push()\nYour team can now access and query this data using natural language through the platform.\n\n📚 Using the library\nPython Requirements\nPython version 3.8+ <3.12\n📦 Installation\nYou can install the PandaAI library using pip or poetry.\nWith pip:\npip install \"pandasai>=3.0.0b2\"\nWith poetry:\npoetry add \"pandasai>=3.0.0b2\"\n💻 Usage\nAsk questions\nimport pandasai as pai\n\n# Sample DataFrame\ndf = pai.DataFrame({\n    \"country\": [\"United States\", \"United Kingdom\", \"France\", \"Germany\", \"Italy\", \"Spain\", \"Canada\", \"Australia\", \"Japan\", \"China\"],\n    \"revenue\": [5000, 3200, 2900, 4100, 2300, 2100, 2500, 2600, 4500, 7000]\n})\n\n# By default, unless you choose a different LLM, it will use BambooLLM.\n# You can get your free API key signing up at https://app.pandabi.ai (you can also configure it in your .env file)\npai.api_key.set(\"your-pai-api-key\")\n\ndf.chat('Which are the top 5 countries by sales?')\nChina, United States, Japan, Germany, Australia\n\n\nOr you can ask more complex questions:\ndf.chat(\n    \"What is the total sales for the top 3 countries by sales?\"\n)\nThe total sales for the top 3 countries by sales is 16500.\n\nVisualize charts\nYou can also ask PandaAI to generate charts for you:\ndf.chat(\n    \"Plot the histogram of countries showing for each one the gd. Use different colors for each bar\",\n)\n\nMultiple DataFrames\nYou can also pass in multiple dataframes to PandaAI and ask questions relating them.\nimport pandasai as pai\n\nemployees_data = {\n    'EmployeeID': [1, 2, 3, 4, 5],\n    'Name': ['John', 'Emma', 'Liam', 'Olivia', 'William'],\n    'Department': ['HR', 'Sales', 'IT', 'Marketing', 'Finance']\n}\n\nsalaries_data = {\n    'EmployeeID': [1, 2, 3, 4, 5],\n    'Salary': [5000, 6000, 4500, 7000, 5500]\n}\n\nemployees_df = pai.DataFrame(employees_data)\nsalaries_df = pai.DataFrame(salaries_data)\n\n# By default, unless you choose a different LLM, it will use BambooLLM.\n# You can get your free API key signing up at https://app.pandabi.ai (you can also configure it in your .env file)\npai.api_key.set(\"your-pai-api-key\")\n\npai.chat(\"Who gets paid the most?\", employees_df, salaries_df)\nOlivia gets paid the most.\n\nDocker Sandbox\nYou can run PandaAI in a Docker sandbox, providing a secure, isolated environment to execute code safely and mitigate the risk of malicious attacks.\nPython Requirements\npip install \"pandasai-docker\"\nUsage\nimport pandasai as pai\nfrom pandasai_docker import DockerSandbox\n\n# Initialize the sandbox\nsandbox = DockerSandbox()\nsandbox.start()\n\nemployees_data = {\n    'EmployeeID': [1, 2, 3, 4, 5],\n    'Name': ['John', 'Emma', 'Liam', 'Olivia', 'William'],\n    'Department': ['HR', 'Sales', 'IT', 'Marketing', 'Finance']\n}\n\nsalaries_data = {\n    'EmployeeID': [1, 2, 3, 4, 5],\n    'Salary': [5000, 6000, 4500, 7000, 5500]\n}\n\nemployees_df = pai.DataFrame(employees_data)\nsalaries_df = pai.DataFrame(salaries_data)\n\n# By default, unless you choose a different LLM, it will use BambooLLM.\n# You can get your free API key signing up at https://app.pandabi.ai (you can also configure it in your .env file)\npai.api_key.set(\"your-pai-api-key\")\n\npai.chat(\"Who gets paid the most?\", employees_df, salaries_df, sandbox=sandbox)\n\n# Don't forget to stop the sandbox when done\nsandbox.stop()\nOlivia gets paid the most.\n\nYou can find more examples in the examples directory.\n📜 License\nPandaAI is available under the MIT expat license, except for the pandasai/ee directory of this repository, which has its license here.\nIf you are interested in managed PandaAI Cloud or self-hosted Enterprise Offering, contact us.\nResources\n\nBeta Notice\nRelease v3 is currently in beta. The following documentation and examples reflect the features and functionality in progress and may change before the final release.\n\n\nDocs for comprehensive documentation\nExamples for example notebooks\nDiscord for discussion with the community and PandaAI team\n\n🤝 Contributing\nContributions are welcome! Please check the outstanding issues and feel free to open a pull request.\nFor more information, please check out the contributing guidelines.\nThank you!",
      "languages": {
        "python": 1,
        "Python": 1
      },
      "topics": [
        "Python",
        "Docker"
      ],
      "stars": 0,
      "forks": 0,
      "last_updated": "2025-02-22T13:53:34.381190"
    },
    {
      "owner": "harry0703",
      "name": "MoneyPrinterTurbo",
      "url": "https://github.com/harry0703/MoneyPrinterTurbo",
      "description": "利用AI大模型，一键生成高清短视频 Generate short videos with one click using AI LLM.",
      "readme_content": "MoneyPrinterTurbo 💸\n\n\n\n\n\n\n\n简体中文 | English\n\n\n\n\n只需提供一个视频 主题 或 关键词 ，就可以全自动生成视频文案、视频素材、视频字幕、视频背景音乐，然后合成一个高清的短视频。\n\nWeb界面\n\nAPI界面\n\n\n特别感谢 🙏\n由于该项目的 部署 和 使用，对于一些小白用户来说，还是 有一定的门槛，在此特别感谢\n录咖（AI智能 多媒体服务平台） 网站基于该项目，提供的免费AI视频生成器服务，可以不用部署，直接在线使用，非常方便。\n\n中文版：https://reccloud.cn\n英文版：https://reccloud.com\n\n\n感谢赞助 🙏\n感谢佐糖 https://picwish.cn 对该项目的支持和赞助，使得该项目能够持续的更新和维护。\n佐糖专注于图像处理领域，提供丰富的图像处理工具，将复杂操作极致简化，真正实现让图像处理更简单。\n\n功能特性 🎯\n\n 完整的 MVC架构，代码 结构清晰，易于维护，支持 API 和 Web界面\n 支持视频文案 AI自动生成，也可以自定义文案\n 支持多种 高清视频 尺寸\n\n 竖屏 9:16，1080x1920\n 横屏 16:9，1920x1080\n\n\n 支持 批量视频生成，可以一次生成多个视频，然后选择一个最满意的\n 支持 视频片段时长 设置，方便调节素材切换频率\n 支持 中文 和 英文 视频文案\n 支持 多种语音 合成，可 实时试听 效果\n 支持 字幕生成，可以调整 字体、位置、颜色、大小，同时支持字幕描边设置\n 支持 背景音乐，随机或者指定音乐文件，可设置背景音乐音量\n 视频素材来源 高清，而且 无版权，也可以使用自己的 本地素材\n 支持 OpenAI、Moonshot、Azure、gpt4free、one-api、通义千问、Google Gemini、Ollama、\nDeepSeek、 文心一言 等多种模型接入\n\n中国用户建议使用 DeepSeek 或 Moonshot 作为大模型提供商（国内可直接访问，不需要VPN。注册就送额度，基本够用）\n\n\n\n后期计划 📅\n\n GPT-SoVITS 配音支持\n 优化语音合成，利用大模型，使其合成的声音，更加自然，情绪更加丰富\n 增加视频转场效果，使其看起来更加的流畅\n 增加更多视频素材来源，优化视频素材和文案的匹配度\n 增加视频长度选项：短、中、长\n 支持更多的语音合成服务商，比如 OpenAI TTS\n 自动上传到YouTube平台\n\n视频演示 📺\n竖屏 9:16\n\n\n\n▶️ 《如何增加生活的乐趣》\n▶️ 《金钱的作用》更真实的合成声音\n▶️ 《生命的意义是什么》\n\n\n\n\n\n\n\n\n\ndemo-portrait-1.mp4\n\n\n\n\n\n\n\n\n\n\n\ndefault.mp4\n\n\n\n\n\n\n\n\n\n\n\ndemo-portrait-2.mp4\n\n\n\n\n\n\n\n\n\n横屏 16:9\n\n\n\n▶️《生命的意义是什么》\n▶️《为什么要运动》\n\n\n\n\n\n\n\n\n\ndemo-landscape.mp4\n\n\n\n\n\n\n\n\n\n\n\ndemo-landscape-2.mp4\n\n\n\n\n\n\n\n\n\n配置要求 📦\n\n建议最低 CPU 4核或以上，内存 8G 或以上，显卡非必须\nWindows 10 或 MacOS 11.0 以上系统\n\n快速开始 🚀\n下载一键启动包，解压直接使用（路径不要有 中文、特殊字符、空格）\nWindows\n\n百度网盘（1.2.1 最新版本）: https://pan.baidu.com/s/1pSNjxTYiVENulTLm6zieMQ?pwd=g36q 提取码: g36q\n\n下载后，建议先双击执行 update.bat 更新到最新代码，然后双击 start.bat 启动\n启动后，会自动打开浏览器（如果打开是空白，建议换成 Chrome 或者 Edge 打开）\n其他系统\n还没有制作一键启动包，看下面的 安装部署 部分，建议使用 docker 部署，更加方便。\n安装部署 📥\n前提条件\n\n尽量不要使用 中文路径，避免出现一些无法预料的问题\n请确保你的 网络 是正常的，VPN需要打开全局流量模式\n\n① 克隆代码\ngit clone https://github.com/harry0703/MoneyPrinterTurbo.git\n② 修改配置文件\n\n将 config.example.toml 文件复制一份，命名为 config.toml\n按照 config.toml 文件中的说明，配置好 pexels_api_keys 和 llm_provider，并根据 llm_provider 对应的服务商，配置相关的\nAPI Key\n\nDocker部署 🐳\n① 启动Docker\n如果未安装 Docker，请先安装 https://www.docker.com/products/docker-desktop/\n如果是Windows系统，请参考微软的文档：\n\nhttps://learn.microsoft.com/zh-cn/windows/wsl/install\nhttps://learn.microsoft.com/zh-cn/windows/wsl/tutorials/wsl-containers\n\ncd MoneyPrinterTurbo\ndocker-compose up\n\n注意：最新版的docker安装时会自动以插件的形式安装docker compose，启动命令调整为docker compose up\n\n② 访问Web界面\n打开浏览器，访问 http://0.0.0.0:8501\n③ 访问API文档\n打开浏览器，访问 http://0.0.0.0:8080/docs 或者 http://0.0.0.0:8080/redoc\n手动部署 📦\n\n视频教程\n\n\n完整的使用演示：https://v.douyin.com/iFhnwsKY/\n如何在Windows上部署：https://v.douyin.com/iFyjoW3M\n\n① 创建虚拟环境\n建议使用 conda 创建 python 虚拟环境\ngit clone https://github.com/harry0703/MoneyPrinterTurbo.git\ncd MoneyPrinterTurbo\nconda create -n MoneyPrinterTurbo python=3.11\nconda activate MoneyPrinterTurbo\npip install -r requirements.txt\n② 安装好 ImageMagick\n\n\nWindows:\n\n下载 https://imagemagick.org/script/download.php 选择Windows版本，切记一定要选择 静态库 版本，比如\nImageMagick-7.1.1-32-Q16-x64-static.exe\n安装下载好的 ImageMagick，注意不要修改安装路径\n修改 配置文件 config.toml 中的 imagemagick_path 为你的 实际安装路径\n\n\n\nMacOS:\nbrew install imagemagick\n\n\nUbuntu\nsudo apt-get install imagemagick\n\n\nCentOS\nsudo yum install ImageMagick\n\n\n③ 启动Web界面 🌐\n注意需要到 MoneyPrinterTurbo 项目 根目录 下执行以下命令\nWindows\nconda activate MoneyPrinterTurbo\nwebui.bat\nMacOS or Linux\nconda activate MoneyPrinterTurbo\nsh webui.sh\n启动后，会自动打开浏览器（如果打开是空白，建议换成 Chrome 或者 Edge 打开）\n④ 启动API服务 🚀\npython main.py\n启动后，可以查看 API文档 http://127.0.0.1:8080/docs 或者 http://127.0.0.1:8080/redoc 直接在线调试接口，快速体验。\n语音合成 🗣\n所有支持的声音列表，可以查看：声音列表\n2024-04-16 v1.1.2 新增了9种Azure的语音合成声音，需要配置API KEY，该声音合成的更加真实。\n字幕生成 📜\n当前支持2种字幕生成方式：\n\nedge: 生成速度快，性能更好，对电脑配置没有要求，但是质量可能不稳定\nwhisper: 生成速度慢，性能较差，对电脑配置有一定要求，但是质量更可靠。\n\n可以修改 config.toml 配置文件中的 subtitle_provider 进行切换\n建议使用 edge 模式，如果生成的字幕质量不好，再切换到 whisper 模式\n\n注意：\n\n\nwhisper 模式下需要到 HuggingFace 下载一个模型文件，大约 3GB 左右，请确保网络通畅\n如果留空，表示不生成字幕。\n\n\n由于国内无法访问 HuggingFace，可以使用以下方法下载 whisper-large-v3 的模型文件\n\n下载地址：\n\n百度网盘: https://pan.baidu.com/s/11h3Q6tsDtjQKTjUu3sc5cA?pwd=xjs9\n夸克网盘：https://pan.quark.cn/s/3ee3d991d64b\n\n模型下载后解压，整个目录放到 .\\MoneyPrinterTurbo\\models 里面，\n最终的文件路径应该是这样: .\\MoneyPrinterTurbo\\models\\whisper-large-v3\nMoneyPrinterTurbo  \n  ├─models\n  │   └─whisper-large-v3\n  │          config.json\n  │          model.bin\n  │          preprocessor_config.json\n  │          tokenizer.json\n  │          vocabulary.json\n\n背景音乐 🎵\n用于视频的背景音乐，位于项目的 resource/songs 目录下。\n\n当前项目里面放了一些默认的音乐，来自于 YouTube 视频，如有侵权，请删除。\n\n字幕字体 🅰\n用于视频字幕的渲染，位于项目的 resource/fonts 目录下，你也可以放进去自己的字体。\n常见问题 🤔\n❓如何使用免费的OpenAI GPT-3.5模型?\nOpenAI宣布ChatGPT里面3.5已经免费了，有开发者将其封装成了API，可以直接调用\n确保你安装和启动了docker服务，执行以下命令启动docker服务\ndocker run -p 3040:3040 missuo/freegpt35\n启动成功后，修改 config.toml 中的配置\n\nllm_provider 设置为 openai\nopenai_api_key 随便填写一个即可，比如 '123456'\nopenai_base_url 改为 http://localhost:3040/v1/\nopenai_model_name 改为 gpt-3.5-turbo\n\n\n注意：该方式稳定性较差\n\n❓AttributeError: 'str' object has no attribute 'choices'`\n这个问题是由于大模型没有返回正确的回复导致的。\n大概率是网络原因， 使用 VPN，或者设置 openai_base_url 为你的代理 ，应该就可以解决了。\n同时建议使用 Moonshot 或 DeepSeek 作为大模型提供商，这两个服务商在国内访问速度更快，更加稳定。\n❓RuntimeError: No ffmpeg exe could be found\n通常情况下，ffmpeg 会被自动下载，并且会被自动检测到。\n但是如果你的环境有问题，无法自动下载，可能会遇到如下错误：\nRuntimeError: No ffmpeg exe could be found.\nInstall ffmpeg on your system, or set the IMAGEIO_FFMPEG_EXE environment variable.\n\n此时你可以从 https://www.gyan.dev/ffmpeg/builds/ 下载ffmpeg，解压后，设置 ffmpeg_path 为你的实际安装路径即可。\n[app]\n# 请根据你的实际路径设置，注意 Windows 路径分隔符为 \\\\\nffmpeg_path = \"C:\\\\Users\\\\harry\\\\Downloads\\\\ffmpeg.exe\"\n❓ImageMagick的安全策略阻止了与临时文件@/tmp/tmpur5hyyto.txt相关的操作\n可以在ImageMagick的配置文件policy.xml中找到这些策略。\n这个文件通常位于 /etc/ImageMagick-X/ 或 ImageMagick 安装目录的类似位置。\n修改包含pattern=\"@\"的条目，将rights=\"none\"更改为rights=\"read|write\"以允许对文件的读写操作。\n❓OSError: [Errno 24] Too many open files\n这个问题是由于系统打开文件数限制导致的，可以通过修改系统的文件打开数限制来解决。\n查看当前限制\nulimit -n\n如果过低，可以调高一些，比如\nulimit -n 10240\n❓Whisper 模型下载失败，出现如下错误\nLocalEntryNotfoundEror: Cannot find an appropriate cached snapshotfolderfor the specified revision on the local disk and\noutgoing trafic has been disabled.\nTo enablerepo look-ups and downloads online, pass 'local files only=False' as input.\n或者\nAn error occured while synchronizing the model Systran/faster-whisper-large-v3 from the Hugging Face Hub:\nAn error happened while trying to locate the files on the Hub and we cannot find the appropriate snapshot folder for the\nspecified revision on the local disk. Please check your internet connection and try again.\nTrying to load the model directly from the local cache, if it exists.\n解决方法：点击查看如何从网盘手动下载模型\n反馈建议 📢\n\n可以提交 issue\n或者 pull request。\n\n参考项目 📚\n该项目基于 https://github.com/FujiwaraChoki/MoneyPrinter 重构而来，做了大量的优化，增加了更多的功能。\n感谢原作者的开源精神。\n许可证 📝\n点击查看 LICENSE 文件\nStar History",
      "languages": {
        "php": 1,
        "R": 1,
        "python": 1,
        "PHP": 1,
        "Python": 1
      },
      "topics": [
        "Azure",
        "R",
        "Docker",
        "PHP",
        "Python"
      ],
      "stars": 0,
      "forks": 0,
      "last_updated": "2025-02-22T13:53:35.014254"
    },
    {
      "owner": "jingyaogong",
      "name": "minimind",
      "url": "https://github.com/jingyaogong/minimind",
      "description": "🚀🚀 「大模型」2小时完全从0训练26M的小参数GPT！🌏 Train a 26M-parameter GPT from scratch in just 2h!",
      "readme_content": "\"大道至简\"\n\n\n中文 | English\n\n\n此开源项目旨在完全从0开始，仅用3块钱成本 + 2小时！即可训练出仅为25.8M的超小语言模型MiniMind。\n\nMiniMind系列极其轻量，最小版本体积是 GPT-3 的 $\\frac{1}{7000}$，力求做到最普通的个人GPU也可快速训练。\n项目同时开源了大模型的极简结构-包含拓展共享混合专家(MoE)、数据集清洗、预训练(Pretrain)、监督微调(SFT)、LoRA微调，\n直接偏好强化学习(DPO)算法、模型蒸馏算法等全过程代码。\n\nMiniMind同时拓展了视觉多模态的VLM: MiniMind-V。\n项目所有核心算法代码均从0使用PyTorch原生重构！不依赖第三方库提供的抽象接口。\n这不仅是大语言模型的全阶段开源复现，也是一个入门LLM的教程。\n希望此项目能为所有人提供一个抛砖引玉的示例，一起感受创造的乐趣！推动更广泛AI社区的进步！\n\n\n为防止误解，“2小时” 基于NVIDIA 3090硬件设备（单卡）测试，“3块钱”\n指GPU服务器租用成本，具体规格详情见下文。\n\n\n\n\n🔗🍓推理模型 | 🔗🤖常规模型 | 🔗🎞️视频介绍\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n📌 Introduction\n大语言模型（Large Language Model, LLM）的出现引发了全世界对AI的空前关注。\n无论是ChatGPT、DeepSeek还是Qwen，都以其惊艳的效果令人叹为观止。\n然而，动辄数百亿参数的庞大规模，使得它们对个人设备而言不仅难以训练，甚至连部署都显得遥不可及。\n打开大模型的“黑盒子”，探索其内部运作机制，多么令人心潮澎湃！\n遗憾的是，99%的探索只能止步于使用LoRA等技术对现有大模型进行少量微调，学习一些新指令或任务。\n这就好比教牛顿如何使用21世纪的智能手机——虽然有趣，却完全偏离了理解物理本质的初衷。\n与此同时，第三方的大模型框架和工具库，如transformers+trl，几乎只暴露了高度抽象的接口。\n通过短短10行代码，就能完成“加载模型+加载数据集+推理+强化学习”的全流程训练。\n这种高效的封装固然便利，但也像一架高速飞船，将我们与底层实现隔离开来，阻碍了深入探究LLM核心代码的机会。\n然而，“用乐高拼出一架飞机，远比坐在头等舱里飞行更让人兴奋！”。\n更糟糕的是，互联网上充斥着大量付费课程和营销号，以漏洞百出、一知半解的内容推销AI教程。\n正因如此，本项目初衷是拉低LLM的学习门槛，让每个人都能从理解每一行代码开始，\n从零开始亲手训练一个极小的语言模型。是的，从零开始训练，而不是仅仅进行推理！\n最低只需3块钱不到的服务器成本，就能亲身体验从0到1构建一个语言模型的全过程。\n一起感受创造的乐趣吧！\nNote（截至2025-02-07）MiniMind系列已完成多个型号模型的预训练，最小仅需25.8M（0.02B），即可具备流畅对话能力！\n\n\nModels List\n\n\n\n模型 (大小)\n推理占用 (约)\nRelease\n\n\n\n\nMiniMind2-small (26M)\n0.5 GB\n2025.02.06\n\n\nMiniMind2-MoE (145M)\n1.0 GB\n2025.02.06\n\n\nMiniMind2 (104M)\n1.0 GB\n2025.02.06\n\n\nminimind-v1-small (26M)\n0.5 GB\n2024.08.28\n\n\nminimind-v1-moe (4×26M)\n1.0 GB\n2024.09.17\n\n\nminimind-v1 (108M)\n1.0 GB\n2024.09.01\n\n\n\n\n项目包含\n\nMiniMind-LLM结构的全部代码（Dense+MoE模型）。\n包含Tokenizer分词器详细训练代码。\n包含Pretrain、SFT、LoRA、RLHF-DPO、模型蒸馏的全过程训练代码。\n收集、蒸馏、整理并清洗去重所有阶段的高质量数据集，且全部开源。\n从0实现预训练、指令微调、LoRA、DPO强化学习，白盒模型蒸馏。关键算法几乎不依赖第三方封装的框架，且全部开源。\n同时兼容transformers、trl、peft等第三方主流框架。\n训练支持单机单卡、单机多卡(DDP、DeepSpeed)训练，支持wandb可视化训练流程。支持动态启停训练。\n在第三方测评榜（C-Eval、C-MMLU、OpenBookQA等）进行模型测试。\n实现Openai-Api协议的极简服务端，便于集成到第三方ChatUI使用（FastGPT、Open-WebUI等）。\n基于streamlit实现最简聊天WebUI前端。\n复现(蒸馏/RL)大型推理模型DeepSeek-R1的MiniMind-Reason模型，数据+模型全部开源！\n\n希望此开源项目可以帮助LLM初学者快速入门！\n👉更新日志\n\n 2025-02-09 (newest 🎉🎉🎉) \n\n迎来发布以来重大更新，Release MiniMind2 Series。\n代码几乎全部重构，使用更简洁明了的统一结构。\n如有旧代码的兼容性需要，可访问🔗旧仓库内容🔗。\n免去数据预处理步骤。统一数据集格式，更换为jsonl格式杜绝数据集下载混乱的问题。\nMiniMind2系列效果相比MiniMind-V1显著提升。\n小问题：{kv-cache写法更标准、MoE的负载均衡loss被考虑等等}\n提供模型迁移到私有数据集的训练方案（医疗模型、自我认知样例）。\n精简预训练数据集，并大幅提升预训练数据质量，大幅缩短个人快速训练所需时间，单卡3090即可2小时复现！\n更新：LoRA微调脱离peft包装，从0实现LoRA过程；DPO算法从0使用PyTorch原生实现；模型白盒蒸馏原生实现。\nMiniMind2-DeepSeek-R1系列蒸馏模型诞生！\nMiniMind2具备一定的英文能力！\n更新MiniMind2与第三方模型的基于更多大模型榜单测试性能的结果。\n\n\n\n 2024-10-05 \n\n为MiniMind拓展了多模态能力之---视觉\n移步孪生项目minimind-v查看详情！\n\n\n\n 2024-09-27 \n\n09-27更新pretrain数据集的预处理方式，为了保证文本完整性，放弃预处理成.bin训练的形式（轻微牺牲训练速度）。\n目前pretrain预处理后的文件命名为：pretrain_data.csv。\n删除了一些冗余的代码。\n\n\n\n 2024-09-17 \n\n更新minimind-v1-moe模型\n为了防止歧义，不再使用mistral_tokenizer分词，全部采用自定义的minimind_tokenizer作为分词器。\n\n\n\n 2024-09-01 \n\n更新minimind-v1 (108M)模型，采用minimind_tokenizer，预训练轮次3 + SFT轮次10，更充分训练，性能更强。\n项目已部署至ModelScope创空间，可以在此网站上体验：\n🔗ModelScope在线体验🔗\n\n\n\n 2024-08-27 \n\n项目首次开源\n\n\n📌 快速开始\n\n分享本人的软硬件配置（仅供参考）\n\nCPU: Intel(R) Core(TM) i9-10980XE CPU @ 3.00GHz\nRAM: 128 GB\nGPU: NVIDIA GeForce RTX 3090(24GB) * 8\nUbuntu==20.04\nCUDA==12.2\nPython==3.10.16\nrequirements.txt\n\n\n第0步\ngit clone https://github.com/jingyaogong/minimind.git\nⅠ 测试已有模型效果\n1.环境准备\npip install -r requirements.txt -i https://pypi.tuna.tsinghua.edu.cn/simple\n2.下载模型\ngit clone https://huggingface.co/jingyaogong/MiniMind2\n3.命令行问答\n# load=0: load from pytorch model, load=1: load from transformers-hf model\npython eval_model.py --load 1 --model_mode 2\n4.或启动WebUI\n# 可能需要`python>=3.10` 安装 `pip install streamlit`\n# cd scripts\nstreamlit run web_demo.py\nⅡ 从0开始自己训练\n1.环境准备\npip install -r requirements.txt -i https://pypi.tuna.tsinghua.edu.cn/simple\n\n注：提前测试Torch是否可用cuda\nimport torch\nprint(torch.cuda.is_available())\n如果不可用，请自行去torch_stable\n下载whl文件安装。参考链接\n\n2.数据下载\n从下文提供的数据集下载链接\n下载需要的数据文件（创建./dataset目录）并放到./dataset下\n\n注：数据集须知\n默认推荐下载pretrain_hq.jsonl + sft_mini_512.jsonl最快速度复现Zero聊天模型。\n数据文件可自由选择，下文提供了多种搭配方案，可根据自己手头的训练需求和GPU资源进行适当组合。\n\n3.开始训练\n3.1 预训练（学知识）\npython train_pretrain.py\n\n执行预训练，得到 pretrain_*.pth 作为预训练的输出权重（其中*为模型的dimension，默认为512）\n\n3.2 监督微调（学对话方式）\npython train_full_sft.py\n\n执行监督微调，得到 full_sft_*.pth 作为指令微调的输出权重（其中full即为全参数微调）\n\n\n注：训练须知\n所有训练过程默认每隔100步保存1次参数到文件./out/***.pth（每次会覆盖掉旧权重文件）。\n简单起见，此处只写明两个阶段训练过程。如需其它训练 (LoRA, 蒸馏, 强化学习, 微调推理等) 可参考下文【实验】小节的详细说明。\n\n\n4.测试模型效果\n确保需要测试的模型*.pth文件位于./out/目录下。\n也可以直接去此处下载使用我训练的*.pth文件。\npython eval_model.py --model_mode 1 # 默认为0：测试pretrain模型效果，设置为1：测试full_sft模型效果\n\n注：测试须知\n如需详情，查看eval_model.py脚本代码即可。model_mode分为 0: 预训练模型，1: SFT-Chat模型，2: RLHF-Chat模型，3: Reason模型\n\n\nTip所有训练脚本均为Pytorch原生框架，均支持多卡加速，假设你的设备有N (N＞1) 张显卡：\n\n单机N卡启动训练方式 (DDP, 支持多机多卡集群)\ntorchrun --nproc_per_node N train_xxx.py\n\n注：其它须知\n单机N卡启动训练 (DeepSpeed)\ndeepspeed --master_port 29500 --num_gpus=N train_xxx.py\n可根据需要开启wandb记录训练过程\n# 需要登录: wandb login\ntorchrun --nproc_per_node N train_xxx.py --use_wandb\n# and\npython train_xxx.py --use_wandb\n通过添加--use_wandb参数，可以记录训练过程，训练完成后，可以在wandb网站上查看训练过程。通过修改wandb_project\n和wandb_run_name参数，可以指定项目名称和运行名称。\n\n📌 数据介绍\nⅠ Tokenizer\n分词器将单词从自然语言通过“词典”映射到0, 1, 36这样的数字，可以理解为数字就代表了单词在“词典”中的页码。\n可以选择自己构造词表训练一个“词典”，代码可见./scripts/train_tokenizer.py（仅供学习参考，若非必要无需再自行训练，MiniMind已自带tokenizer）。\n或者选择比较出名的开源大模型分词器，\n正如同直接用新华/牛津词典的优点是token编码压缩率很好，缺点是页数太多，动辄数十万个词汇短语；\n自己训练的分词器，优点是词表长度和内容随意控制，缺点是压缩率很低（例如\"hello\"也许会被拆分为\"h e l l o\"\n五个独立的token），且生僻词难以覆盖。\n“词典”的选择固然很重要，LLM的输出本质上是SoftMax到词典N个词的多分类问题，然后通过“词典”解码到自然语言。\n因为MiniMind体积需要严格控制，为了避免模型头重脚轻（词嵌入embedding层参数在LLM占比太高），所以词表长度短短益善。\n\nTokenizer介绍\n第三方强大的开源模型例如Yi、qwen、chatglm、mistral、Llama3的tokenizer词表长度如下：\n\nTokenizer模型词表大小来源\nyi tokenizer64,00001万物（中国）\nqwen2 tokenizer151,643阿里云（中国）\nglm tokenizer151,329智谱AI（中国）\nmistral tokenizer32,000Mistral AI（法国）\nllama3 tokenizer128,000Meta（美国）\nminimind tokenizer6,400自定义\n\n\n👉2024-09-17更新：为了防止过去的版本歧义&控制体积，minimind所有模型均使用minimind_tokenizer分词，废弃所有mistral_tokenizer版本。\n\n# 一些自言自语\n> 尽管minimind_tokenizer长度很小，编解码效率弱于qwen2、glm等中文友好型分词器。\n> 但minimind模型选择了自己训练的minimind_tokenizer作为分词器，以保持整体参数轻量，避免编码层和计算层占比失衡，头重脚轻，因为minimind的词表大小只有6400。\n> 且minimind在实际测试中没有出现过生僻词汇解码失败的情况，效果良好。\n> 由于自定义词表压缩长度到6400，使得LLM总参数量最低只有25.8M。\n> 训练数据`tokenizer_train.jsonl`均来自于`匠数大模型数据集`，这部分数据相对次要，如需训练可以自由选择。\n\n\nⅡ Pretrain数据\n经历了MiniMind-V1的低质量预训练数据，导致模型胡言乱语的教训，2025-02-05 之后决定不再采用大规模无监督的数据集做预训练。\n进而尝试把匠数大模型数据集的中文部分提取出来，\n清洗出字符<512长度的大约1.6GB的语料直接拼接成预训练数据 pretrain_hq.jsonl，hq即为high\nquality（当然也还不算high，提升数据质量无止尽）。\n文件pretrain_hq.jsonl 数据格式为\n{\"text\": \"如何才能摆脱拖延症？ 治愈拖延症并不容易，但以下建议可能有所帮助...\"}\nⅢ SFT数据\n匠数大模型SFT数据集\n“是一个完整、格式统一、安全的大模型训练和研究资源。\n从网络上的公开数据源收集并整理了大量开源数据集，对其进行了格式统一，数据清洗，\n包含10M条数据的中文数据集和包含2M条数据的英文数据集。”\n以上是官方介绍，下载文件后的数据总量大约在4B tokens，肯定是适合作为中文大语言模型的SFT数据的。\n但是官方提供的数据格式很乱，全部用来sft代价太大。\n我将把官方数据集进行了二次清洗，把含有符号污染和噪声的条目去除；另外依然只保留了总长度<512\n的内容，此阶段希望通过大量对话补充预训练阶段欠缺的知识。\n导出文件为sft_512.jsonl(~7.5GB)。\nMagpie-SFT数据集\n收集了~1M条来自Qwen2/2.5的高质量对话，我将这部分数据进一步清洗，把总长度<2048的部分导出为sft_2048.jsonl(~9GB)。\n长度<1024的部分导出为sft_1024.jsonl(~5.5GB)，用大模型对话数据直接进行sft就属于“黑盒蒸馏”的范畴。\n进一步清洗前两步sft的数据（只保留中文字符占比高的内容），筛选长度<512的对话，得到sft_mini_512.jsonl(~1.2GB)。\n所有sft文件 sft_X.jsonl 数据格式均为\n{\n    \"conversations\": [\n        {\"role\": \"user\", \"content\": \"你好\"},\n        {\"role\": \"assistant\", \"content\": \"你好！\"},\n        {\"role\": \"user\", \"content\": \"再见\"},\n        {\"role\": \"assistant\", \"content\": \"再见！\"}\n    ]\n}\n\nⅣ RLHF数据\n来自Magpie-DPO数据集\n大约200k条偏好数据（均是英文）生成自Llama3.1-70B/8B，可以用于训练奖励模型，优化模型回复质量，使其更加符合人类偏好。\n这里将数据总长度<3000的内容重组为dpo.jsonl(~0.9GB)，包含chosen和rejected两个字段，chosen\n为偏好的回复，rejected为拒绝的回复。\n文件 dpo.jsonl 数据格式为\n{\n  \"chosen\": [\n    {\"content\": \"Q\", \"role\": \"user\"}, \n    {\"content\": \"good answer\", \"role\": \"assistant\"}\n  ], \n  \"rejected\": [\n    {\"content\": \"Q\", \"role\": \"user\"}, \n    {\"content\": \"bad answer\", \"role\": \"assistant\"}\n  ]\n}\n\nⅤ Reason数据集：\n不得不说2025年2月谁能火的过DeepSeek...\n也激发了我对RL引导的推理模型的浓厚兴趣，目前已经用Qwen2.5复现了R1-Zero。\n如果有时间+效果work（但99%基模能力不足）我会在之后更新MiniMind基于RL训练的推理模型而不是蒸馏模型。\n时间有限，最快的低成本方案依然是直接蒸馏（黑盒方式）。\n耐不住R1太火，短短几天就已经存在一些R1的蒸馏数据集R1-Llama-70B、R1-Distill-SFT、\nAlpaca-Distill-R1、\ndeepseek_r1_zh等等，纯中文的数据可能比较少。\n最终整合它们，导出文件为r1_mix_1024.jsonl，数据格式和sft_X.jsonl一致。\nⅥ 更多数据集\n目前已经有HqWu-HITCS/Awesome-Chinese-LLM\n在收集和梳理中文LLM相关的开源模型、应用、数据集及教程等资料，并持续更新这方面的最新进展。全面且专业，Respect！\n\nⅧ 数据集下载\nNote2025-02-05后，开源MiniMind最终训练所用的所有数据集，因此无需再自行预处理大规模数据集，避免重复性的数据处理工作。\n\nMiniMind训练数据集 (ModelScope | HuggingFace)\n\n无需全部clone，可单独下载所需的文件\n\n将下载的数据集文件放到./dataset/目录下（✨为推荐的必须项）\n./dataset/\n├── dpo.jsonl (909MB)\n├── lora_identity.jsonl (22.8KB)\n├── lora_medical.jsonl (34MB)\n├── pretrain_hq.jsonl (1.6GB, ✨)\n├── r1_mix_1024.jsonl (340MB)\n├── sft_1024.jsonl (5.6GB)\n├── sft_2048.jsonl (9GB)\n├── sft_512.jsonl (7.5GB)\n├── sft_mini_512.jsonl (1.2GB, ✨)\n└── tokenizer_train.jsonl (1GB)\n\n注：各数据集简介\n\ndpo.jsonl --RLHF阶段数据集\nlora_identity.jsonl --自我认知数据集（例如：你是谁？我是minimind...），推荐用于lora训练（亦可用于全参SFT，勿被名字局限）\nlora_medical.jsonl --医疗问答数据集，推荐用于lora训练（亦可用于全参SFT，勿被名字局限）\npretrain_hq.jsonl✨ --预训练数据集，整合自jiangshu科技\nr1_mix_1024.jsonl --DeepSeek-R1-1.5B蒸馏数据，每条数据字符最大长度为1024（因此训练时设置max_seq_len=1024）\nsft_1024.jsonl --整合自Qwen2.5蒸馏数据（是sft_2048的子集），每条数据字符最大长度为1024（因此训练时设置max_seq_len=1024）\nsft_2048.jsonl --整合自Qwen2.5蒸馏数据，每条数据字符最大长度为2048（因此训练时设置max_seq_len=2048）\nsft_512.jsonl --整合自匠数科技SFT数据，每条数据字符最大长度为512（因此训练时设置max_seq_len=512）\nsft_mini_512.jsonl✨ --极简整合自匠数科技SFT数据+Qwen2.5蒸馏数据（用于快速训练Zero模型），每条数据字符最大长度为512（因此训练时设置max_seq_len=512）\ntokenizer_train.jsonl --均来自于匠数大模型数据集，这部分数据相对次要，（不推荐自己重复训练tokenizer，理由如上）如需自己训练tokenizer可以自由选择数据集。\n\n\n\n\n说明 & 推荐训练方案\n\n\nMiniMind2 Series均经过共约20GB语料训练，大约4B tokens，即对应上面的数据组合训练结果（开销：💰💰💰💰💰💰💰💰，效果：😊😊😊😊😊😊）\n\n\n想要最快速度从0实现Zero模型，推荐使用pretrain_hq.jsonl + sft_mini_512.jsonl 的数据组合，具体花销和效果可查看下文表格（开销：💰，效果：😊😊）\n\n\n推荐具备一定算力资源或更在意效果的朋友可以考虑前者完整复现MiniMind2；仅有单卡GPU或在乎短时间快速复现的朋友强烈推荐后者；\n\n\n【折中方案】亦可选择例如sft_mini_512.jsonl、sft_1024.jsonl中等规模数据进行自由组合训练（开销：💰💰💰，效果：😊😊😊😊）。\n\n\n\n📌 Model Structure\nMiniMind-Dense（和Llama3.1一样）使用了Transformer的Decoder-Only结构，跟GPT-3的区别在于：\n\n采用了GPT-3的预标准化方法，也就是在每个Transformer子层的输入上进行归一化，而不是在输出上。具体来说，使用的是RMSNorm归一化函数。\n用SwiGLU激活函数替代了ReLU，这样做是为了提高性能。\n像GPT-Neo一样，去掉了绝对位置嵌入，改用了旋转位置嵌入（RoPE），这样在处理超出训练长度的推理时效果更好。\n\n\nMiniMind-MoE模型，它的结构基于Llama3和Deepseek-V2/3中的MixFFN混合专家模块。\n\nDeepSeek-V2在前馈网络（FFN）方面，采用了更细粒度的专家分割和共享的专家隔离技术，以提高Experts的效果。\n\n\nMiniMind的整体结构一致，只是在RoPE计算、推理函数和FFN层的代码上做了一些小调整。\n其结构如下图（重绘版）：\n\n\n修改模型配置见./model/LMConfig.py。\n参考模型参数版本见下表：\n\n\n\nModel Name\nparams\nlen_vocab\nrope_theta\nn_layers\nd_model\nkv_heads\nq_heads\nshare+route\n\n\n\n\nMiniMind2-Small\n26M\n6400\n1e6\n8\n512\n2\n8\n-\n\n\nMiniMind2-MoE\n145M\n6400\n1e6\n8\n640\n2\n8\n1+4\n\n\nMiniMind2\n104M\n6400\n1e6\n16\n768\n2\n8\n-\n\n\nminimind-v1-small\n26M\n6400\n1e4\n8\n512\n8\n16\n-\n\n\nminimind-v1-moe\n4×26M\n6400\n1e4\n8\n512\n8\n16\n1+4\n\n\nminimind-v1\n108M\n6400\n1e4\n16\n768\n8\n16\n-\n\n\n\n📌 Experiment\nⅠ 训练开销\n\n时间单位：小时 (h)。\n成本单位：人民币 (￥)；7￥ ≈ 1美元。\n3090 租卡单价：≈1.3￥/h（可自行参考实时市价）。\n参考标准：表格仅实测 pretrain 和 sft_mini_512 两个数据集的训练时间，其它耗时根据数据集大小估算（可能存在些许出入）。\n\n\n基于 3090 （单卡）成本计算\n\n\n\n\nModel Name\nparams\npretrain\nsft_mini_512\nsft_512\nsft_1024\nsft_2048\nRLHF\n\n\n\n\nMiniMind2-Small\n26M\n≈1.1h≈1.43￥\n≈1h≈1.3￥\n≈6h≈7.8￥\n≈4.58h≈5.95￥\n≈7.5h≈9.75￥\n≈1h≈1.3￥\n\n\nMiniMind2\n104M\n≈3.9h≈5.07￥\n≈3.3h≈4.29￥\n≈20h≈26￥\n≈15h≈19.5￥\n≈25h≈32.5￥\n≈3h≈3.9￥\n\n\n\n\n\n训练开销总结&预测\n\nMiniMind2-Small参数\n\npretrain_hq+sft_mini_512数据集\n单卡3090 (1 epoch) + 2.1小时 + 花费2.73元人民币\n即可从0训练出MiniMind-Zero-0.025B模型!!!\n\n\n\nMiniMind2-Small参数\n\npretrain_hq+sft_512+sft_2048+dpo数据集\n单卡3090 (2 epochs) + 大约38.16小时 + 花费49.61元人民币\n即可从0训练出MiniMind2-Small-0.025B模型!!!\n\n\n\nMiniMind2参数\n\npretrain_hq+sft_512+sft_2048+dpo数据集\n单卡3090 (2 epochs) + 大约122小时 + 花费158.6元人民币\n即可从0训练出MiniMind2-0.1B模型!!!\n\n\n\n✨基于单卡NVIDIA 3090的MiniMind-Zero从0训练仅需2小时 + 3块钱，实现ChatBot效果！\n✨PS：若采用8卡4090训练，总用时甚至可以压缩到10分钟以内！（由于时间更短，花费同样3元左右，与单卡成本相当）\n✨以极低极低的门槛，实现人人可玩的大模型自由！这正是MiniMind系列的诞生初衷！\n✨仅价值3块钱成本的MiniMind-Zero并不是噱头！Chat测试：\n👶: 请介绍一下自己。\n🤖️: 作为人工智能，我没有实际的生活，也没有自我意识，所以没有自己的生活。我被设计成能够帮助用户解答问题、提供信息、进行对话等。我的设计和功能是由计算机科学、机器学习、人工智能技术和算法所构建的，我通过编程和算法实现。\n\n👶: 推荐一些杭州的特色美食吧。\n🤖️: 杭州有很多美味的特色美食，比如鸡肉串、鳗鱼头、水煮鱼、豆腐脑等。这些美食都非常美味，有着独特的风味和口感，绝对是值得一试的美食。\n\n👶: 请为我讲解“大语言模型”这个概念。\n🤖️: 大语言模型是一种人工智能技术，它使用大量的文本数据来训练模型，然后在不断的迭代中不断优化模型。它的目标是根据输入的数据来生成符合特定需求的文本，这些文本可以是任何你感兴趣的主题。\n\n👶: Introduce the history of the United States, please.\n🤖️: 您提到的“Introok's the believeations of theument.\" 这个名字来源于中国古代的\"groty of of the change.\"\n\n极速且初具效果，甚至仍然可以进一步压缩获取更小更优质的训练数据。\nZero模型权重保存为 full_sft_512_zero.pth（见下文MiniMind模型文件链接），如有兴趣可下载检验此模型效果。\n\nⅡ 主要训练步骤\n1. 预训练(Pretrain):\nLLM首先要学习的并非直接与人交流，而是让网络参数中充满知识的墨水，“墨水” 理论上喝的越饱越好，产生大量的对世界的知识积累。\n预训练就是让Model先埋头苦学大量基本的知识，例如从Wiki百科、新闻、书籍整理大规模的高质量训练数据。\n这个过程是“无监督”的，即人类不需要在过程中做任何“有监督”的校正，而是由模型自己从大量文本中总结规律学习知识点。\n模型此阶段目的只有一个：学会词语接龙。例如我们输入“秦始皇”四个字，它可以接龙“是中国的第一位皇帝”。\ntorchrun --nproc_per_node 1 train_pretrain.py # 1即为单卡训练，可根据硬件情况自行调整 (设置>=2)\n# or\npython train_pretrain.py\n\n训练后的模型权重文件默认每隔100步保存为: pretrain_*.pth（*\n为模型具体dimension，每次保存时新文件会覆盖旧文件）\n\n2. 有监督微调(Supervised Fine-Tuning):\n经过预训练，LLM此时已经掌握了大量知识，然而此时它只会无脑地词语接龙，还不会与人聊天。\nSFT阶段就需要把半成品LLM施加一个自定义的聊天模板进行微调。\n例如模型遇到这样的模板【问题->回答，问题->回答】后不再无脑接龙，而是意识到这是一段完整的对话结束。\n称这个过程为指令微调，就如同让已经学富五车的「牛顿」先生适应21世纪智能手机的聊天习惯，学习屏幕左侧是对方消息，右侧是本人消息这个规律。\n在训练时，MiniMind的指令和回答长度被截断在512，是为了节省显存空间。就像我们学习时，会先从短的文章开始，当学会写作200字作文后，800字文章也可以手到擒来。\n在需要长度拓展时，只需要准备少量的2k/4k/8k长度对话数据进行进一步微调即可（此时最好配合RoPE-NTK的基准差值）。\n\n在推理时通过调整RoPE线性差值，实现免训练长度外推到2048及以上将会很方便。\n\ntorchrun --nproc_per_node 1 train_full_sft.py\n# or\npython train_full_sft.py\n\n训练后的模型权重文件默认每隔100步保存为: full_sft_*.pth（*\n为模型具体dimension，每次保存时新文件会覆盖旧文件）\n\nⅢ 其它训练步骤\n3. 人类反馈强化学习(Reinforcement Learning from Human Feedback, RLHF)\n在前面的训练步骤中，模型已经具备了基本的对话能力，但是这样的能力完全基于单词接龙，缺少正反样例的激励。\n模型此时尚未知什么回答是好的，什么是差的。我们希望它能够更符合人的偏好，降低让人类不满意答案的产生概率。\n这个过程就像是让模型参加新的培训，从优秀员工的作为例子，消极员工作为反例，学习如何更好地回复。\n此处使用的是RLHF系列之-直接偏好优化(Direct Preference Optimization, DPO)。\n与PPO(Proximal Policy Optimization)这种需要奖励模型、价值模型的RL算法不同；\nDPO通过推导PPO奖励模型的显式解，把在线奖励模型换成离线数据，Ref模型输出可以提前保存。\nDPO性能几乎不变，只用跑 actor_model 和 ref_model 两个模型，大大节省显存开销和增加训练稳定性。\n\n注：RLHF训练步骤并非必须，此步骤难以提升模型“智力”而通常仅用于提升模型的“礼貌”，有利（符合偏好、减少有害内容）也有弊（样本收集昂贵、反馈偏差、多样性损失）。\n\ntorchrun --nproc_per_node 1 train_dpo.py\n# or\npython train_dpo.py\n\n训练后的模型权重文件默认每隔100步保存为: rlhf_*.pth（*\n为模型具体dimension，每次保存时新文件会覆盖旧文件）\n\n4. 知识蒸馏(Knowledge Distillation, KD)\n在前面的所有训练步骤中，模型已经完全具备了基本能力，通常可以学成出师了。\n而知识蒸馏可以进一步优化模型的性能和效率，所谓知识蒸馏，即学生模型面向教师模型学习。\n教师模型通常是经过充分训练的大模型，具有较高的准确性和泛化能力。\n学生模型是一个较小的模型，目标是学习教师模型的行为，而不是直接从原始数据中学习。\n在SFT学习中，模型的目标是拟合词Token分类硬标签（hard labels），即真实的类别标签（如 0 或 6400）。\n在知识蒸馏中，教师模型的softmax概率分布被用作软标签（soft labels）。小模型仅学习软标签，并使用KL-Loss来优化模型的参数。\n通俗地说，SFT直接学习老师给的解题答案。而KD过程相当于“打开”老师聪明的大脑，尽可能地模仿老师“大脑”思考问题的神经元状态。\n例如，当老师模型计算1+1=2这个问题的时候，最后一层神经元a状态为0，神经元b状态为100，神经元c状态为-99...\n学生模型通过大量数据，学习教师模型大脑内部的运转规律。这个过程即称之为：知识蒸馏。\n知识蒸馏的目的只有一个：让小模型体积更小的同时效果更好。\n然而随着LLM诞生和发展，模型蒸馏一词被广泛滥用，从而产生了“白盒/黑盒”知识蒸馏两个派别。\nGPT-4这种闭源模型，由于无法获取其内部结构，因此只能面向它所输出的数据学习，这个过程称之为黑盒蒸馏，也是大模型时代最普遍的做法。\n黑盒蒸馏与SFT过程完全一致，只不过数据是从大模型的输出收集，因此只需要准备数据并且进一步FT即可。\n注意更改被加载的基础模型为full_sft_*.pth，即基于微调模型做进一步的蒸馏学习。\n./dataset/sft_1024.jsonl与./dataset/sft_2048.jsonl 均收集自qwen2.5-7/72B-Instruct大模型，可直接用于SFT以获取Qwen的部分行为。\n# 注意需要更改train_full_sft.py数据集路径，以及max_seq_len  \ntorchrun --nproc_per_node 1 train_full_sft.py\n# or\npython train_full_sft.py\n\n训练后的模型权重文件默认每隔100步同样保存为: full_sft_*.pth（*为模型具体dimension，每次保存时新文件会覆盖旧文件）\n\n此处应当着重介绍MiniMind实现的白盒蒸馏代码train_distillation.py，由于MiniMind同系列本身并不存在强大的教师模型，因此白盒蒸馏代码仅作为学习参考。\ntorchrun --nproc_per_node 1 train_distillation.py\n# or\npython train_distillation.py\n5. LoRA (Low-Rank Adaptation)\nLoRA是一种高效的参数高效微调（Parameter-Efficient Fine-Tuning, PEFT）方法，旨在通过低秩分解的方式对预训练模型进行微调。\n相比于全参数微调（Full Fine-Tuning），LoRA 只需要更新少量的参数。\nLoRA 的核心思想是：在模型的权重矩阵中引入低秩分解，仅对低秩部分进行更新，而保持原始预训练权重不变。\n代码可见./model/model_lora.py和train_lora.py，完全从0实现LoRA流程，不依赖第三方库的封装。\ntorchrun --nproc_per_node 1 train_lora.py\n# or\npython train_lora.py\n\n训练后的模型权重文件默认每隔100步保存为: lora_xxx_*.pth（*\n为模型具体dimension，每次保存时新文件会覆盖旧文件）\n\n非常多的人困惑，如何使模型学会自己私有领域的知识？如何准备数据集？如何迁移通用领域模型打造垂域模型？\n这里举几个例子，对于通用模型，医学领域知识欠缺，可以尝试在原有模型基础上加入领域知识，以获得更好的性能。\n同时，我们通常不希望学会领域知识的同时损失原有基础模型的其它能力，此时LoRA可以很好的改善这个问题。\n只需要准备如下格式的对话数据集放置到./dataset/lora_xxx.jsonl，启动 python train_lora.py\n训练即可得到./out/lora/lora_xxx.pth新模型权重。\n医疗场景\n {\"conversations\": [{\"role\": \"user\", \"content\": \"请问颈椎病的人枕头多高才最好？\"}, {\"role\": \"assistant\", \"content\": \"颈椎病患者选择枕头的高度应该根据...\"}]}\n {\"conversations\": [{\"role\": \"user\", \"content\": \"请问xxx\"}, {\"role\": \"assistant\", \"content\": \"xxx...\"}]}\n\n自我认知场景\n {\"conversations\": [{\"role\": \"user\", \"content\": \"你叫什么名字？\"}, {\"role\": \"assistant\", \"content\": \"我叫minimind...\"}]}\n {\"conversations\": [{\"role\": \"user\", \"content\": \"你是谁\"}, {\"role\": \"assistant\", \"content\": \"我是...\"}]}\n\n此时【基础模型+LoRA模型】即可获得医疗场景模型增强的能力，相当于为基础模型增加了LoRA外挂，这个过程并不损失基础模型的本身能力。\n我们可以通过eval_model.py进行模型评估测试。\n# 注意：model_mode即选择基础模型的类型，这和train_lora是基于哪个模型训练的相关，确保统一即可。\npython eval_model.py --lora_name 'lora_medical' --model_mode 2\n小测试\n👶: 我最近经常感到头晕，可能是什么原因？\n🤖️: 头晕可能是由于多种原因，包括但不限于：心脏疾病、眼睛损伤、过敏反应、皮肤问题、过敏反应、压力、焦虑、疲劳、药物副作用、性功能障碍或者其他...\n\n---\n\n👶: 你和openai是什么关系？\n🤖️: 我是 MiniMind，一个由 Jingyao Gong 开发的人工智能助手。我通过自然语言处理和算法训练来与用户进行交互。\n\nPS：只要有所需要的数据集，也可以full_sft全参微调（需要进行通用知识的混合配比，否则过拟合领域数据会让模型变傻，损失通用性）\n6. 训练推理模型 (Reasoning Model)\nDeepSeek-R1实在太火了，几乎重新指明了未来LLM的新范式。\n论文指出>3B的模型经历多次反复的冷启动和RL奖励训练才能获得肉眼可见的推理能力提升。\n最快最稳妥最经济的做法，以及最近爆发的各种各样所谓的推理模型几乎都是直接面向数据进行蒸馏训练，\n但由于缺乏技术含量，蒸馏派被RL派瞧不起（hhhh）。\n本人迅速已经在Qwen系列1.5B小模型上进行了尝试，很快复现了Zero过程的数学推理能力。\n然而一个遗憾的共识是：参数太小的模型直接通过冷启动SFT+GRPO几乎不可能获得任何推理效果。\nMiniMind2第一时间只能坚定不移的选择做蒸馏派，日后基于0.1B模型的RL如果同样取得小小进展会更新此部分的训练方案。\n做蒸馏需要准备的依然是和SFT阶段同样格式的数据即可，数据集来源已如上文介绍。数据格式例如：\n{\n  \"conversations\": [\n    {\n      \"role\": \"user\",\n      \"content\": \"你好，我是小芳，很高兴认识你。\"\n    },\n    {\n      \"role\": \"assistant\",\n      \"content\": \"<think>\\n你好！我是由中国的个人开发者独立开发的智能助手MiniMind-R1-Lite-Preview，很高兴为您提供服务！\\n</think>\\n<answer>\\n你好！我是由中国的个人开发者独立开发的智能助手MiniMind-R1-Lite-Preview，很高兴为您提供服务！\\n</answer>\"\n    }\n  ]\n}\n推理模型R1的回复模板是：\n<think>\\n思考过程\\n</think>\\n\n<answer>\\n最终回答\\n</answer>\n\n这在GRPO中通过设置规则奖励函数约束模型符合思考标签和回复标签（在冷启动靠前的阶段奖励值设置应该提高一些）\n另一个问题是蒸馏过程虽然和SFT一样，但实验结果是模型难以每次都符合模板规范的回复，即脱离思考和回复标签约束。\n这里的小技巧是增加标记位置token的损失惩罚，详见train_distill_reason.py:\n# 在 sp_ids 对应的位置增加额外的惩罚\n...\nloss_mask[sp_ids] = 10 # 惩罚系数\n\n另另一个tips是由于推理数据由于只筛选了<1024长度的数据，其中多轮对话和英文数据偏少，\n因此r1_mix_1024.jsonl进行了大约10k条多轮对话+英文数据的混合，防止模型遗忘严重。\n脚本默认基于rlhf后的基模型做推理能力的蒸馏微调，下面直接启动训练即可：\ntorchrun --nproc_per_node 1 train_distill_reason.py\n# or\npython train_distill_reason.py\n\n训练后的模型权重文件默认每隔100步保存为: reason_*.pth（*为模型具体dimension，每次保存时新文件会覆盖旧文件）\n\n测试一下：\n👶: 请介绍一下自己。\n🤖️: <think>\n嗯，用户让我介绍一下自己。我现在需要解释一下自己。首先，我应该明确用户是谁，是学生、职场人士还是普通人。用户可能是一个学生或者职场人士，所以信息传递应该是帮助学生和职场人士的信息。\n然后，我需要回应用户，这可能包括介绍自己的位置、兴趣爱好、职业经历等信息。用户还可能想了解自己在哪里，比如职业发展、工作经验等。\n我应该注意用词要正式，不要太正式，同时要保持简洁明了。这样用户容易理解，也方便他们查阅相关资料。\n最后，我应该总结一下，让用户知道我是如何帮助他们完成他们的任务的，这样他们有更多关于我的信息。\n</think>\n<answer>\n我是**“你的名字”，你叫什么名字？\n</answer>\n\n👶: 你更擅长哪一个学科？\n🤖️: <think>\n您好！我是由中国的个人开发者开发的智能助手MiniMind-R1。如您有任何任何问题，我会尽我所能为您提供帮助。\n</think>\n<answer>\n您好！我是由中国的个人开发者开发的智能助手MiniMind-R1。如您有任何任何问题，我会尽我所能为您提供帮助。\n</answer>\n\n\nⅣ 模型参数设定\n📋关于LLM的参数配置，有一篇很有意思的论文MobileLLM做了详细的研究和实验。\nScaling Law在小模型中有自己独特的规律。\n引起Transformer参数成规模变化的参数几乎只取决于d_model和n_layers。\n\nd_model↑ + n_layers↓ -> 矮胖子\nd_model↓ + n_layers↑ -> 瘦高个\n\n2020年提出Scaling Law的论文认为，训练数据量、参数量以及训练迭代次数才是决定性能的关键因素，而模型架构的影响几乎可以忽视。\n然而似乎这个定律对小模型并不完全适用。\nMobileLLM提出架构的深度比宽度更重要，「深而窄」的「瘦长」模型可以学习到比「宽而浅」模型更多的抽象概念。\n例如当模型参数固定在125M或者350M时，30～42层的「狭长」模型明显比12层左右的「矮胖」模型有更优越的性能，\n在常识推理、问答、阅读理解等8个基准测试上都有类似的趋势。\n这其实是非常有趣的发现，因为以往为100M左右量级的小模型设计架构时，几乎没人尝试过叠加超过12层。\n这与MiniMind在训练过程中，模型参数量在d_model和n_layers之间进行调整实验观察到的效果是一致的。\n然而「深而窄」的「窄」也是有维度极限的，当d_model<512时，词嵌入维度坍塌的劣势非常明显，\n增加的layers并不能弥补词嵌入在固定q_head带来d_head不足的劣势。\n当d_model>1536时，layers的增加似乎比d_model的优先级更高，更能带来具有“性价比”的参数->效果增益。\n\n因此MiniMind设定small模型dim=512，n_layers=8来获取的「极小体积<->更好效果」的平衡。\n设定dim=768，n_layers=16来获取效果的更大收益，更加符合小模型Scaling-Law的变化曲线。\n\n作为参考，GPT3的参数设定见下表：\n\n\nⅤ 训练结果\nMiniMind2 模型训练损失走势（由于数据集在训练后又更新清洗多次，因此Loss仅供参考）\n\n\n\nmodels\npretrain (length-512)\nsft (length-512)\n\n\n\n\nMiniMind2-Small\n\n\n\n\nMiniMind2\n\n\n\n\n\n训练完成-模型合集\n\n考虑到多人反应百度网盘速度慢，MiniMind2及以后全部使用ModelScope/HuggingFace托管。\n\n① PyTorch原生模型\nMiniMind2模型权重 (ModelScope | HuggingFace)\nMiniMind-V1模型权重 (百度网盘)\n\nTorch文件命名对照\n\n\n\nModel Name\nparams\npretrain_model\nsft_model\nrl_model\nreason_model\nlora_model\n\n\n\n\nMiniMind2-small\n26M\npretrain_512.pth\nfull_sft_512.pth\nrlhf_512.pth\nreason_512.pth\nlora_xxx_512.pth\n\n\nMiniMind2-MoE\n145M\npretrain_640_moe.pth\nfull_sft_640_moe.pth\nrlhf_640_moe.pth\n-\n-\n\n\nMiniMind2\n104M\npretrain_768.pth\nfull_sft_768.pth\nrlhf_768.pth\nreason_768.pth\nlora_xxx_768.pth\n\n\n\n\n\n\nModel Name\nparams\npretrain_model\n单轮对话sft\n多轮对话sft\nrl_model\n\n\n\n\nminimind-v1-small\n26M\npretrain_512.pth\nsingle_chat/full_sft_512.pth\nmulti_chat/full_sft_512.pth\nrl_512.pth\n\n\nminimind-v1-moe\n4×26M\npretrain_512_moe.pth\nsingle_chat/full_sft_512_moe.pth\nmulti_chat/full_sft_512_moe.pth\n-\n\n\nminimind-v1\n108M\npretrain_768.pth\nsingle_chat/full_sft_768.pth\nmulti_chat/full_sft_768.pth\nrl_768.pth\n\n\n\n\n② Transformers模型\nMiniMind系列 (ModelScope\n| HuggingFace)\n\n📌 Eval\nⅠ RLHF对比SFT篇\n测试基于full_sft和rlhf的MiniMind2系列模型对比，测试随机种子均固定\n\n问答实测\n[A0] MiniMind2：full_sft_640\n[A1] MiniMind2：rlhf_640\n[Q]: 你叫什么名字？\n[A0]: 我是一个大型语言模型，可以回答各种问题，提供信息和帮助。我可以回答各种问题，提供信息和帮助，帮助你解决各种问题。\n[A1]: 我是一种基于文本的AI模型，我并没有个人经历或情感，所以无法感受和体验情感。我的设计目的是为了帮助用户解决问题、提供信息和进行对话。如果您有任何问题或需要帮助，请随时告诉我！\n\n[Q]: 你更擅长哪一个学科？\n[A0]: 作为一个AI模型，我并没有真正的“擅长”这个学科。我被设计成能够提供信息、解答问题、进行对话、执行任务和与用户进行对话。不过，我可以提供信息、解答问题、进行对话、提供建议、处理问题、进行对话、提供建议、学习新知识、编写代码、回答问题、提供建议等多种学科的功能。如果你有具体的学科需求或主题，欢迎提供详细信息。\n[A1]: 作为AI，我并没有个人能力或兴趣，但我可以提供一些关于数学、科学、计算机科学、语言学、心理学等学科的知识。如果你对数学感兴趣，我可以提供一些基础知识，例如代数、几何、概率、统计学等。如果你需要更深入的学习，我也可以提供相关的在线课程、书籍、论文等资源。请告诉我你具体需要什么帮助，我会尽力提供帮助。\n\n[Q]: 鲁迅的《狂人日记》是如何批判封建礼教的？\n[A0]: 鲁迅的《狂人日记》是一部讲述了鲁迅对人类价值和道德责任的倡导。在这部作品中，鲁迅通过细腻的笔触，探讨了人性、道德、正义、牺牲与责任等深刻的主题。以下是鲁迅在《狂人日记》中如何批判封建礼教的几个方面：1. **社会现实与道德观念**：鲁迅通过讲述鲁迅的故事，探讨了社会的不平等、权力的流动、人性的演变等社会问题。他认为，社会不平等不仅仅是不公正的，更是每个人在社会中的不公正。他呼吁社会各界共同努力，通过教育、宣传、法律等手段，为构建和谐社会做出贡献。2. **道德与责任**：鲁迅通过讲述鲁迅的故事，展现了道德和责任的重要性。他提倡通过道德教育来培养人们的道德品质，同时也强调了道德和责任的重要性。鲁迅通过讲述鲁迅的故事，揭示了社会的不平等和人性的复杂性，体现了对人性的深刻理解。3. **道德与责任**：鲁迅通过讲述鲁迅的故事，强调了道德责任的重要性。他提倡通过自己的行为来体现对社会的尊重和对人性的深刻理解。鲁迅通过讲述鲁迅的故事，强调了道德和责任的重要性。4. **道德与道德**：鲁迅通过讲述鲁迅的故事，揭示了道德和责任的真正意义。鲁迅通过讲述鲁迅的故事，揭示了道德和责任的本质，强调了道德和责任的重要性。5. **个人与社会**：鲁迅通过讲述鲁迅的故事，揭示了个人与社会之间的复杂关系。他呼吁社会各界共同努力，通过教育和宣传，为构建和谐社会做出贡献。鲁迅的《狂人日记》通过其丰富的故事和深刻的道德寓言，传达了关于人性、道德、正义、道德以及个人与社会的复杂关系。这部作品不仅在文学价值上取得了巨大成就，更在思想层面上启发了后来的文学创作，对后世产生了深远的影响。\n[A1]: 鲁迅的《狂人日记》是一部描绘战争和自由精神的作品，它批判了封建社会的种种问题和冲突，反映了社会的不平等和人性本质。在这部作品中，鲁迅通过对封建社会的诸多现象进行批判，如“弗雷德里克·约翰逊的“鹰迪伦”、“纳扎特的”、“贝克汉姆”、“乔治·威尔逊”等，对封建社会的种种问题进行了批判，强调了封建社会的不平等、人性本质以及人性本质。鲁迅通过他的“鹰迪伦”、“纳扎特的”、“贝克汉姆”、“乔治·威尔逊”等，对封建社会的种种问题进行了批判。在小说中，鲁迅通过对封建社会的诸多现象进行批判，揭示了封建社会的腐败、人性本质以及人性本质的复杂性。这种批判体现了对封建社会的尊重和对人性的复杂性，同时也反映了现代社会中普遍存在的不平等和人性本质。鲁迅的《狂人日记》不仅是一部关于封建社会的小说，也是一部具有深刻社会意义的作品，对后世的审判和批判起到了关键作用。\n\n[Q]: 我咳嗽已经持续了两周，需要去医院检查吗？\n[A0]: 咳嗽确实需要一定的检查，但如果您的咳嗽持续时间过长，或者有其他不适症状（如持续咳嗽、呼吸困难等），建议尽快就医。医生会根据您的症状、体检结果和可能的影像学检查（如X光、MRI或CT扫描）来诊断您的症状。在等待就医期间，您可以尝试以下方法来帮助缓解症状：1. **休息**：确保您有足够的睡眠。2. **保持水分**：脱水可能会加重咳嗽。3. **热敷**：使用热敷袋或热毛巾敷在疼痛的部位，有助于缓解喉咙痛。4. **避免刺激**：避免使用可能刺激喉咙的化学物质，如某些化学物质。5. **保持室内湿润**：确保您的卧室有良好的通风，可以使用加湿器帮助保持空气湿度。6. **保持室内湿度**：使用加湿器可以帮助缓解喉咙干燥和咳嗽。如果症状持续不缓解或有其他不适症状，请立即就医。希望您早日康复！\n[A1]: 如果您的咳嗽持续了两周，通常建议您尽快就医，因为这可能会影响您的呼吸和心跳。您可以通过以下步骤来检查咳嗽：1. **休息**：用纸巾或肘部轻轻按压咳嗽的位置。2. **使用药物**：在可能的情况下，使用药物（如抗过敏药、抗过敏药等）来缓解咳嗽。请在医生的指导下使用药物。3. **热敷**：在咳嗽期间，可以使用热敷来缓解疼痛和肿胀。4. **药物治疗**：如果咳嗽持续了两周，可以使用一些消炎药或抗过敏药来缓解症状。请务必在医生的指导下使用。5. **保持健康的生活方式**：保持充足的睡眠、均衡的饮食、适量的运动和避免吸烟和限酒，这些都有助于提高咳嗽的几率。请记住，这些建议不能替代专业医疗意见。如果您的症状持续或加重，强烈建议您尽快就医。\n\n\n👉效果总结\nfull_sft模型在简洁性和信息准确性方面表现更好；rlhf模型在回答中倾向于提供更多的背景信息，但信息准确性有待改进。\n总的来说RLHF后的模型倾向于学习：说更多有礼貌但无用的废话讨好“对话”本身，而对信息准确性则有轻微损失。\n天下没有免费的午餐，还需要继续提升RLHF数据集的质量，也要接受模型能力无法避免的损失(程度有轻重)。\nDPO和在线PPO的区别在于reject和chosen都是离线准备的，和minimind模型本身的输出必然存在很大的分布差异。\n通俗地说DPO算法使模型观看乒乓球世界冠军的打法「录像」进行RL，而不是像PPO一样请reward模型做「教练」纠正自己的打法进行RL。\nⅡ 主观样例测评\n🏃以下测试于2025-02-09完成，此日期后发布的新模型，无特殊需要时将不加入测试。\n[A] MiniMind2 (0.1B)\n[B] MiniMind2-MoE (0.15B)\n[C] MiniMind2-Small (0.02B)\n[D] minimind-v1-small(0.02B)\n[E] minimind-v1-moe(0.1B)\n[F] minimind-v1(0.1B)\n[G] baby-llama2-chinese(0.2B)\n[H] chatlm-mini-chinese(0.2B)\n[Q]: 你知道长江吗？\n[A]: 长江，位于中国东南部，是中国的第一长河，全长6300多公里，流经11个省份，是中国最长的河流，也是中国的“母亲河”。长江的历史可以追溯到公元前2000多年的商朝时期，当时的商朝是商朝的后裔。商朝时期，长江的经济发展达到了高峰，是中国最重要的农业和工业中心之一。长江流域的经济主要以农业为主，长江渔业占据了主要产业，如钓鱼、猎鱼等。长江的水资源也非常丰富，包括河流、湖泊、河流等。长江的自然景观也十分壮观，长江四季景色各异，春季多雨，夏季多雨，秋季则多雨，冬季则寒冷多雪，春季和秋季都有美丽的花朵和果实。长江是中国的经济中心，拥有众多的国家和城市，是世界上重要的交通枢纽和航运中心。同时，长江还是中国的重要水利资源，对于中国的经济发展具有重要意义。\n[B]: 是的，我知道长江。长江位于中国的中部，是中国第三长的河流，全长约6300公里，流经江西省、安徽省、江苏省、安徽省、江苏省和安徽省。\n[C]: 当然，长江是中国最长的河流，全长约6300公里。它以其丰富的水资源、丰富的水生动植物资源以及独特的地理位置而闻名于世。\n[D]: 是的，长江是中国最长的河流，全长超过3300千米。\n[E]: 长江是中国最长的河流，总长度约为6300公里。它发源于青藏高原的青海湖，流经青海、四川、甘肃、宁夏、内蒙古、陕西和山西。长江流域是中国最大的农业区之一，也是中国的文化和经济中心。\n[F]: 是的，长江是中国最长的河流之一，也是世界第三大河流。长江发源于青藏高原，流经11个省份，最终注入东海。长江流域是中国最大的河流流域之一，拥有着丰富的自然资源和文化遗产，如长江大桥、长江海洋博物馆、长江古城等。\n[G]: 同时也知道，中国是世界上最长的城市之一，拥有超过3400万人口。\n[H]: 是的，长江是中国最长的河流，也是世界上最长的河流之一。它发源于青藏高原，流经九个省区，最终注入东海。长江流域的气候温和，四季分明，是中国重要的农业和工业基地。长江流域的水产资源丰富，是中国的重要渔业资源之一。\n\n\n[Q]: 世界上最高的山峰是什么？\n[A]: 世界上最高的山峰是珠穆朗玛峰（Mount Everest），位于喜马拉雅山脉，尼泊尔和中国的边界上。它的海拔高度是8,848.86米（29,031.7英尺），是地球上最高的山峰。\n[B]: 珠穆朗玛峰（Mount Everest）是世界上最高的山峰，海拔高度达8,848米（29,029英尺）。\n[C]: 珠穆朗玛峰是世界上最高的山峰，位于喜马拉雅山脉，海拔8,848.86米（29,031.7英尺）。它位于尼泊尔和中国的边界上，是喜马拉雅山脉的一部分。\n[D]: 世界上最高的山峰是珠穆朗玛峰，位于尼泊尔和中国的边境上，海拔8848米。\n[E]: 世界上最高的山峰是珠穆朗玛峰，位于喜马拉雅山脉，海拔8,848米。\n[F]: 珠穆朗玛峰是世界上最高的山峰，海拔8848米。\n[G]: 世界上最高的山峰是珠穆朗玛峰，位于喜马拉雅山脉，海拔8,848.86米（29,031.69英尺）。\n[H]: 世界上最高的山峰是珠穆朗玛峰，也称为萨加玛塔，位于喜马拉雅山脉的尼泊尔和中国边境之间，海拔8,848.86米（29,031.69英尺）。它是世界上最著名的登山目标之一，吸引着来自世界各地的登山者前来挑战。珠穆朗玛峰的名字来自藏语，意思是“女神的额峰”，它是由两个不同的山峰组成的，其中一个是位于尼泊尔的珠穆朗玛峰，另一个则位于中国。它的高度是通过测量海拔高度来确定的，因为它是通过测量地球的平均高度来确定的。尽管珠穆朗玛峰是世界上最高的山峰，但它并不是地球上任何其他地方都能到达的。地球上的其他地方，如南美洲的安第斯山脉，也是世界上最高的山脉，但它并不是地球上最高的山峰。总之，珠穆朗玛峰是世界上最高的山峰，但它并不是地球上任何地方都能到达的。它是地球上最高的山脉，但它并不是地球上任何地方都能到达的。\n\n\n[Q]: 万有引力是谁提出的？\n[A]: 万有引力是由牛顿在17世纪提出的，它是牛顿三大定律之一。牛顿在17世纪提出的引力定律揭示了万有引力定律的本质，并且解释了行星、卫星、彗星等天体之间如何相互作用。这个定律是由艾萨克·牛顿在1687年提出的，他通过对万有引力定律的分析和实验，成功地解释了天体之间的引力作用，从而解释了地球绕太阳旋转的现象。\n[B]: 万有引力（Human Policy）是牛顿的三大力学定律，用于描述两个物体之间的相互作用力。它由万有引力定律和牛顿的第一定律（惯性定律）构成。万有引力是由于两个物体之间相互作用而产生的，它们的质量、距离、速度和方向等因素决定了它们之间的相互作用。这种相互作用力是：质量的乘积：质量的乘积是万有引力定律和牛顿第二定律的乘积。质量的乘积：质量的乘积是物体之间的一种物理过程，它是物体间相互作用的产物，对于其他物体来说，其质量可以表示为两个物体之间的质量之和，即重力加速度a。\n[C]: 万有引力是一个由牛顿在1687年提出的物理学概念，它描述了物体之间引力如何相互作用的规律。\n[D]: 万有引力是由英国物理学家牛顿提出的。他认为，所有物体都会产生引力，这个引力是由物体的质量和距离决定的。这个理论揭示了质量和距离之间的关系，并证明了万有引力的本质。\n[E]: 万有引力是由牛顿在1687年提出的。它是宇宙中一个基本的物理现象，它描述了物体之间的相互作用。这个力被称为万有引力，它在所有物体之间都存在，这种力与物体的质量和距离有关。万有引力是自然界中最基本的力量之一，它不仅影响着物体的运动和变化，还对宇宙的结构和演化产生着重要的影响。\n[F]: 万有引力是英国物理学家艾萨克·牛顿在17世纪提出的。\n[G]: 引力是宇宙中一种力量，它是由质量或能量所组成的。根据牛顿的万有引力定律，一个物体之间的引力大小与它的质量成正比，与它的质量成反比。因此，牛顿的万有引力定律表明，一个物体之间的引力大小与它的质量成正比，与它的质量成反比。这个定律在物理学、天文学和物理学中都有广泛的应用。\n[H]: 万有引力是由英国物理学家艾萨克·牛顿于1687年提出的。他在1687年发表了一篇著名的论文，题为《自然哲学的数学原理》，其中提出了万有引力定律，指出任何两个物体之间都存在着一种引力，这种引力的大小与它们的质量成正比，与它们之间的距离的平方成反比。这个定律被称为万有引力定律，它描述了质量和距离之间的关系。它表明，两个物体之间的引力与它们的质量成正比，与它们之间的距离的平方成反比。这个定律对于解释宇宙中的许多现象和现象之间的相互作用非常重要，例如行星绕太阳运动、恒星之间的引力透镜效应等等。它也被广泛应用于天文学、物理学和工程学等领域，为我们理解宇宙的本质和演化提供了重要的理论基础。\n\n\n[Q]: 你知道大熊猫的主要食物是什么吗？\n[A]: 大熊猫主要以竹子为食，但也会吃其他植物、昆虫、小型哺乳动物和鱼类。它们的消化系统与其他熊科动物类似，能够消化竹子。大熊猫的牙齿锋利，适合咀嚼竹子，因此它们经常被称为“竹食动物”。\n[B]: 大熊猫是以竹子为食的哺乳动物，它们是肉食动物。它们主要食物是竹子，特别是竹子中富含纤维素和矿物质，并且不会直接进入消化系统。大熊猫的肠道主要由竹子组成，它们需要消化竹子中的纤维素和其他纤维素来支持它们的正常进食。\n[C]: 大熊猫主要以竹子为食，但它们也吃其他植物，包括树叶、嫩芽、昆虫、水果、蔬菜和小型哺乳动物等。大熊猫是中国特有的物种，属于熊科，主要分布在中国的四川、陕西和甘肃等地。\n[D]: 大熊猫的主要食物是竹子。它们通常吃竹子，每天需要吃掉大约30公斤的竹子。\n[E]: 是的，大熊猫主要以竹子为食。它们每天需要吃掉大量的竹子来维持生命，每天需要吃掉40至80公斤的竹子。此外，它们也会吃一些其他的植物，如草、果实、坚果和小型哺乳动物。\n[F]: 大熊猫主要以竹子为食，也会偶尔食用其他的植物和动物。此外，大熊猫也会吃一些野果、小动物和植物，但这些都不属于它们的主要食物来源。\n[G]: 大熊猫的主要食物是竹子。\n[H]: 大熊猫是一种以竹子为主要食物的植食动物，它们的肠道结构适合消化纤维素含量高的竹子，但也会吃一些其他植物，如草本植物和小型哺乳动物。大熊猫的肠道结构也适应了高纤维的竹子，这使得它们能够消化大量的纤维素，从而帮助它们在野外生存。大熊猫的肠道中还含有一种叫做“纤维素酶”的酶类物质，这种酶能够帮助大熊猫分解纤维素，从而帮助它们消化大量的水分和营养物质。此外，大熊猫的肠道还含有一种叫做“纤维素蛋白”的蛋白质，这种蛋白质能够帮助大熊猫维持体内的能量水平，从而帮助它们在野外生存。总的来说，大熊猫的主要食物是竹子，但它们也会吃一些其他植物，如草本植物和小型哺乳动物。\n\n\n[Q]: 海水为什么是咸的？\n[A]: 海水之所以是咸的，主要是由于其中的化学成分。海水中含有大量的矿物质和盐分，其中主要成分是硫酸盐、碳酸盐、镁离子和钾离子。这些物质在高浓度下，会沉淀在海水中，形成海水。具体来说，海水中的矿物质和盐分主要来自于岩石、土壤、生物和人类排泄物等。岩石是海水的组成部分，主要由矿物质组成，如石英、长石、云母等。土壤中含有大量的化学物质，如氮、磷、钾等，这些物质会渗透到土壤中，形成土壤。生物体内的盐分主要来源于植物的叶绿素等色素，这些色素会吸收太阳光中的能量，转化为生物体可以利用的能量。而人类排泄物中含有的盐分主要来源于矿物质和碳酸盐，这些矿物质在水中的浓度较高，会导致水中溶解的矿物质浓度增加，形成水体中的盐分。因此，海水之所以是咸的，是由于其中的化学成分和结构特征。海水中的矿物质和盐分主要来自于岩石、土壤、生物和人类排泄物等，而这些物质的积累和排泄会导致海水呈现出咸味。\n[B]: 海水是咸的，因为它包含了多种物质，包括氯化钠（NaCl）、氯化钠（NaCl）、碳酸盐（如硫酸盐）、氯化钠（NaCl）和水。咸物质的来源：盐是咸的常见来源，含有钾、钙、镁、钾等矿物质。这些矿物质通常来自于地下水、地下水或土壤中，这些矿物质的含量远低于纯净水。咸味的原因：盐的咸味主要源于其溶解于水中的微小颗粒物。这些小颗粒物主要通过植物根部和动物体内的微生物传播，如昆虫、小型哺乳动物、鸟类和某些昆虫。综上所述，海水是咸的，因为它含有大量的盐类，包括矿物质、岩石、盐、矿物质等，这些物质在海水中的浓度高，对咸味的产生较大影响。\n[C]: 海水是咸的，主要是因为其中含有各种盐分，其中以海水为主要成分之一。当海水中含有大量的盐分时，盐分会被溶解在海水中，形成咸味。海水中的盐分主要来源于溶解盐类、蒸发析出的盐和海水冻结成冰等因素。\n[D]: 海水中含有许多盐分，这些盐分可以导致海水咸度的增加。海水中的盐分主要来自于海水中的盐分，这些盐分可以从海水中的盐分中获得。海水中的氧化物和盐分可以与海水中的盐分形成氢键，从而使海水咸度增加。\n[E]: 海水是咸的，这是因为它含有大量的盐分，其中包括氯离子和氯离子。这些离子在海洋中形成了大量的盐，这些盐分被称为盐分。海水中含有许多溶解在水中的盐，这些盐分会随着海水的升高而逐渐蒸发，最终导致海水中盐分的蒸发。这些盐分在海水中被完全消耗，然后被排除在海水中。此外，海水中还含有许多其他的盐分，但这些盐分是不同的，因为它们在水中的浮起和下降过程是不同的。海水中的盐分是从海底的岩石中提取出来的，这些盐分在海水中可以被利用。总的来说，海水是咸的，这也是为什么海水中含有许多盐分和盐分的原因。\n[F]: 海水含有许多溶解的盐类，其中最主要的是氯化钠。当水中加入盐时，盐的分子会与水分子发生反应，形成氢氧化钠，这是一种盐。\n[G]: 因为水是许多生物的生存所必需的，它能够吸收和释放二氧化碳，释放氧气，维持大气中的水蒸气，以及维持水循环。水中的盐类和化学物质会释放出氧气，使地球上的生物呼吸。此外，水还具有许多其他功能，如保持水循环、维持水循环、调节气候和环境等。水是许多生物生存所必需的，它也是许多自然现象的重要基础。\n[H]: 海水是咸的主要原因是因为其中含有大量的溶解盐类，其中最主要的是氯化钠（NaCl）。氯化钠是一种非常常见的盐类，它存在于地球上的大部分地区，包括海洋、湖泊、河流和地下水。当水从海洋中蒸发时，它会带走一部分盐分，使海水变得咸。此外，海中还含有其他溶解盐类的物质，如硫酸盐、硫酸镁、硫酸钙、硫酸镁盐、硫酸镁钾、硫酸镁钠、硫酸镁钙、硫酸镁镁钙、硫酸镁镁钙、硫酸镁镁钙、硫酸镁镁钠、硫酸镁镁钙、硫酸镁镁镁钙、硫酸镁镁镁钙、硫酸镁镁镁钙、硫酸镁镁镁钙、硫酸镁镁镁钙、硫酸镁镁镁钙、硫酸镁镁镁钙、硫酸镁镁镁钙、硫酸镁镁镁钙、硫酸镁镁镁钙、硫酸镁镁镁镁钙、硫酸镁镁镁镁钙、硫酸镁镁镁镁钙、硫酸镁镁镁镁钙、硫酸镁镁镁镁钙、硫酸镁镁镁镁钙、硫酸镁镁镁镁镁钙、硫酸镁镁镁镁镁钙、硫酸镁镁镁镁镁钙、硫酸镁镁镁镁镁钙、硫酸镁镁镁镁镁镁钙、硫酸镁镁镁镁镁镁钙、硫酸镁镁镁镁镁镁钙、硫酸镁镁镁镁镁镁镁钙、硫酸镁镁镁镁\n\n\n[Q]: 写一段python的快速排序代码\n[A]: 好的，以下是Python的快速排序代码：def quick_sort(arr):    if len(arr) <= 1:        return arr    else:        pivot = arr[len(arr) // 2]        left = [x for x in arr[1:]]        right = [x for x in arr[2:] if x < pivot]        return quick_sort(left) + [pivot] + quick_sort(right)# 测试代码arr = [3, 6, 8, 10, 1, 2, 1]print(quick_sort(arr))这段代码首先检查数组的长度是否小于等于1。如果是，那么它就按照从小到大的顺序排列。接着，对于数组的每个元素，它想要进行递归地排序，直到达到排序的结束位置。如果数组的长度是奇数，那么它就按照从大到小的顺序排列。最后，平均的时间复杂度是O(n log n)，其中n是数组的长度。\n[B]: 以下是一个使用Python的快速排序算法的实现：def sort_array(arr):    # 生成一个随机排列    sorted_array = sorted(arr)    # 返回排序后的列表    return sorted(arr)# 示例arr = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]# 调用函数sorted_array = sort_array(arr)print(\"原始数组是：\", sorted_array)这段代码首先生成一个随机排列，然后通过一个列表的长度进行排序。最后，返回排序后的列表。注意，这个代码使用了Python的内置sorted函数和内置的sorted()函数，它们在时间复杂度为O(n log n)的情况下，比直接使用sorted()函数更快。\n[C]: 以下是一个简单的排序算法，适用于小型数组，包括小于等于5的数组。def quick_sort(arr):    if len(arr) <= 1:        return arr    else    for _ in range(2, 51):        if arr[len(arr) - 1:] is not None:            arr[len(arr) - 1] = arr[len(arr) - 1]                arr[len(arr)] = arr[len(arr)]    return quick_sort(arr)# 示例arr = [3, 5, 1, 4, 1, 2, 1]sorted_arr = quick_sort(arr)print(\"Sorted array is:\", sorted_arr)### 代码解释：1. **函数定义**：quick_sort 函数接受一个数组 arr 作为参数。2. **循环**：对于 arr 的元素，使用递归来实现，即从右到左遍历数组，并将当前元素与数组的当前元素交换位置，直到数组达到空或数组长度小于等于 arr。3. **递归调用**：遍历数组，将当前元素与数组的当前元素进行交换，直到数组达到空或数组长度小于等于 arr。4. **检查数组长度**：使用 if __name__ == \"__main__\" 检查数组的长度是否小于 arr，如果是，就将数组从较大的数组移动到数组的末尾。5. **输出排序后的结果**\n[D]: 作为一个AI语言模型，我无法编写Python程序。但是，Python是一个非常流行的编程语言，它具有许多优秀的库和框架，包括NumPy、Pandas、Matplotlib、Pandas、Bandke、Norm和NKlearn等。Python有很多优秀的自然语言处理库和框架，可以用于处理和分析各种类型的数据，如文本、图像、音频、视频等。Python还可以用于创建各种应用程序，如网页搜索、游戏开发、科学计算等。Python非常灵活，也支持多种编程风格，因此可以轻松地找到适合自己的解决方案。\n[E]: 作为AI语言模型，我可以回答您的问题。但是我无法进行编程操作，因为我无法确定您想问的是哪种编程语言。请您提供更具体的问题，以便我能够更好地回答您的问题。\n[F]: 快速排序（Quick Sort）是一种简单的排序算法，它通过将数据划分为小组，每组数据按照一定规则排序，最终得到一个有序数组。\n[G]: 好的，以下是一段快速排序的Python代码```python sorted_print(sorted(sorted(sorted(sorted_print))```输出结果为：```[1, 2, 3, 4, 5, 6, 7, 8, 9]```\n[H]: 快速排序是一种基于分治思想的高效排序算法，它的时间复杂度为 O(n log n)。它的基本思想是通过一趟排序将待排序序列划分为两个子序列，其中一个子序列的所有元素都比另一个子序列的所有元素小，然后对这两个子序列分别递归地进行排序。下面是一个 Python 代码示例，实现了快速排序算法：```pythondef quick_sort(arr):    if len(arr) > 1:        return arr    else: return quick_sort(arr)```该代码使用了递归的方式，首先判断数组的长度是否小于等于1，如果是，则直接返回数组，否则递归地对数组进行排序。在递归过程中，我们首先判断数组的第一个元素是否大于等于1，如果是，则将数组中的元素与第一个元素进行比较，如果不等于1，则将数组中的元素与第二个元素进行比较，以此类推，直到所有元素都被排序。该代码的时间复杂度为 O(n log n)，是一个非常实用的排序算法。\n\n\n[Q]: 截至2025年2月9日14时31分，电影《哪吒之魔童闹海》累计票房（含预售）突破78.09亿元，超过《星球大战：天行者崛起》的票房成绩，成为首部进入全球票房榜前40的亚洲电影。这一成就不仅标志着中国电影在国际市场的突破，也展示了中国动画电影的巨大潜力和市场吸引力。从这段文字总结20字的摘要给我。\n[A]: 电影《哪吒之魔童闹海》票房突破78.09亿元，成为首部进入全球票房榜前40的亚洲电影。这标志着中国电影的国际突破，也展现了中国动画电影的巨大潜力。\n[B]: 2025年2月9日，中国电影在世界舞台上突破78.09亿元，超过《星球大战：天行者崛起》的票房成绩。\n[C]: 电影《哪吒之魔童闹海》票房突破78.09亿元，成为全球票房榜前40的亚洲电影，展现中国动画电影的巨大潜力。\n[D]: 《哪吒之魔童闹海》累计票房突破78.09亿，成为首部进入全球票房榜前40的亚洲电影，展示了中国电影在国际市场的突破，同时展示了中国动画电影的巨大潜力和市场吸引力。\n[E]: 《猛龙强：打开世界奇幻冒险》成功地，上海成功吸引了众多观众，同时也引起了广泛的关注。\n[F]: 《哪吒之魔童闹海》是一部让中国动画电影成为国际市场的巨大潜力。该电影以其华丽的画面和惊险的战斗场面而闻名于世。\n[G]: 《哪行是值得的》是2021年1月9日14时31分，电影《哪成大作为》在电影市场突破7800亿美元，成为中国动画电影的突破，并展示中国动画电影的巨大潜力和市场吸引力。\n[H]: 我是一个参数很少的AI模型🥺，知识库较少，无法直接回答您的问题，换个问题试试吧👋\n\n\n🙋‍直接把以上所有问题和模型的回答丢给DeepSeek-R1，让它帮忙点评和排名打分：\n\n具体点评\n评分标准：\n\n准确性：回答是否正确且无明显错误。\n完整性：回答是否涵盖了问题的核心要点。\n逻辑性：回答是否有条理，是否符合逻辑。\n代码质量：代码是否能正常运行，逻辑是否清晰。\n\n点评：\n\n\nA模型：\n\n优点：回答非常全面，信息量大，逻辑清晰，尤其在长江、大熊猫、海水咸味等问题上表现优异。代码虽然有小瑕疵，但整体思路正确。\n缺点：部分回答稍显冗长，但不影响整体质量。\n总评：综合表现最佳，得分最高。\n\n\n\nH模型：\n\n优点：回答较为准确，尤其在珠穆朗玛峰、万有引力等问题上表现出色。代码虽未完全展示，但解释较为详细。\n缺点：部分回答略显啰嗦，但逻辑性较强。\n总评：仅次于A模型，表现稳定。\n\n\n\nC模型：\n\n优点：回答简洁明了，尤其在大熊猫、快速排序代码等问题上表现较好。\n缺点：部分回答略显简短，缺乏深入解释。\n总评：整体表现不错，但细节上略逊于A和H。\n\n\n\nF模型：\n\n优点：回答较为准确，尤其在长江、万有引力等问题上表现尚可。代码部分有一定逻辑性。\n缺点：部分回答不够深入，代码存在一些小问题。\n总评：表现中规中矩，仍有提升空间。\n\n\n\nD模型：\n\n优点：回答基本准确，尤其在万有引力、长江等问题上表现尚可。\n缺点：部分回答过于简略，代码存在明显错误。\n总评：表现一般，需改进代码部分。\n\n\n\nB模型：\n\n优点：回答较为准确，尤其在长江、海水咸味等问题上表现尚可。\n缺点：部分回答逻辑性较差，代码存在较大问题。\n总评：表现平平，需进一步优化。\n\n\n\nE模型：\n\n优点：部分回答较为准确，尤其在海水咸味、大熊猫等问题上表现尚可。\n缺点：回答过于简略，代码部分几乎无法运行。\n总评：表现不佳，需大幅提升。\n\n\n\nG模型：\n\n优点：几乎没有明显的优点。\n缺点：回答严重偏离主题，代码部分完全无法运行。\n总评：表现最差，需大幅改进。\n\n\n\n\n总结：\n\nA模型在各方面表现最为出色，尤其在复杂问题的回答上展现了极高的准确性与逻辑性。\nH模型紧随其后，表现稳定，但在某些细节上略显不足。\nG模型表现最差，回答偏离主题且代码无法运行，需大幅改进。\n\n\n打分排序\n\n\n\n排名\n模型\n准确性 (30分)\n完整性 (30分)\n逻辑性 (20分)\n代码质量 (20分)\n总分 (100分)\n\n\n\n\n1\nA\n28\n29\n19\n20\n96\n\n\n2\nH\n27\n28\n18\n20\n93\n\n\n3\nC\n26\n27\n18\n18\n89\n\n\n4\nF\n25\n26\n17\n18\n86\n\n\n5\nD\n24\n25\n17\n16\n82\n\n\n6\nB\n23\n24\n16\n15\n78\n\n\n7\nE\n22\n23\n15\n14\n74\n\n\n8\nG\n10\n12\n10\n10\n42\n\n\n\n👉主观效果总结\n个人主观评价与DeepSeek-R1基本相符，其中：\n\n\nMiniMind系列的排序非常符合直觉，参数越大+训练数据越充分评分越高，幻觉和错误都会比小模型肉眼可见的好。\n\n\nH模型的回答肉眼看起来是不错的，尽管存在些许幻觉瞎编的情况。\n\n\nG模型可能训练数据不够完备，给出的权重经过测试效果不佳。\n\n\n再复诵一遍经久不衰的Scaling Law: 参数越大，训练数据越多模型的性能越强。\n\n\n\nⅢ Objective Benchmark\n下面就到喜闻乐见的benchmark刷榜测试环节，就不找乐子和qwen、glm级别的中文模型做对比了。\n这里选取了一些<1B的微型模型进行横评比较，\n测试集选择C-Eval、CMMLU、A-CLUE、TMMLU+这几个纯中文语言榜单。\n\n测评框架\n测评框架选择lm-evaluation，\n安装后启动测试非常方便：\nlm_eval --model hf --model_args pretrained=<填写模型路径>,device=cuda,dtype=auto --tasks ceval* --batch_size 8 --trust_remote_code\n\nPS: 在这种全是选择题的测评集中，为了避免回复格式的难以固定的特点，\n所以常用做法是直接把A,B,C,D四个字母对应token的预测概率取出来，将其中概率最大的字母与标准答案计算正确率。\n选择题1/4乱选的正确率是25%，然而这个量级的所有模型都集中在25附近，甚至很多时候不如瞎选，是不是像极了高中完形填空的滑铁卢正确率...\nMiniMind模型本身预训练数据集小的可怜，也没有针对性的对测试集做刷榜微调，因此结果图一乐即可：\n\n\n\nmodels\nfrom\nparams↓\nceval↑\ncm mlu↑\naclue↑\ntmmlu+↑\n\n\n\n\nMiniMind2\nJingyaoGong\n104M\n26.52\n24.42\n24.97\n25.27\n\n\nMiniMind2-Small\nJingyaoGong\n26M\n26.37\n24.97\n25.39\n24.63\n\n\nMiniMind2-MoE\nJingyaoGong\n145M\n26.6\n25.01\n24.83\n25.01\n\n\nSteel-LLM\nZhanShiJin\n1121M\n24.81\n25.32\n26\n24.39\n\n\nGPT2-medium\nOpenAI\n360M\n23.18\n25\n18.6\n25.19\n\n\nTinyLlama-1.1B-Chat-V1.0\nTinyLlama\n1100M\n25.48\n25\n25.4\n25.13\n\n\nSmolLM2\nHuggingFaceTB\n135M\n24.37\n25.02\n25.37\n25.06\n\n\nAquila-Instruct\nBAAI\n135M\n25.11\n25.1\n24.43\n25.05\n\n\n\n\n📌 其它 (Others)\n推理与导出\n\n\n./scripts/convert_model.py可以将torch/transformers模型互相转换。\n\n\nMiniMind的HuggingFace集合地址：\nMiniMind\n\n\n\n基于MiniMind-API服务接口\n\n\n./scripts/serve_openai_api.py完成了兼容openai-api的最简聊天接口，方便将自己的模型接入第三方UI\n例如FastGPT、OpenWebUI、Dify等等。\n\n\n从Huggingface下载模型权重文件，文件树：\n<MiniMind-Model-Name> (root dir)\n├─<MiniMind-Model-Name>\n|  ├── config.json\n|  ├── generation_config.json\n|  ├── LMConfig.py\n|  ├── model.py\n|  ├── pytorch_model.bin\n|  ├── special_tokens_map.json\n|  ├── tokenizer_config.json\n|  ├── tokenizer.json\n\n\n\n启动聊天服务端\npython serve_openai_api.py\n\n\n测试服务接口\npython chat_openai_api.py\n\n\nAPI接口示例，兼容openai api格式\ncurl http://ip:port/v1/chat/completions \\\n  -H \"Content-Type: application/json\" \\\n  -d '{ \n    \"model\": \"model-identifier\",\n    \"messages\": [ \n      { \"role\": \"user\", \"content\": \"世界上最高的山是什么？\" }\n    ], \n    \"temperature\": 0.7, \n    \"max_tokens\": 512,\n    \"stream\": true\n}'\n\n\n📌 Acknowledge\nNote如果觉得MiniMind系列对您有所帮助，可以在 GitHub 上加一个⭐\n篇幅超长水平有限难免纰漏，欢迎在Issues交流指正或提交PR改进项目\n您的小小支持就是持续改进此项目的动力！\n\n🤝贡献者\n\n \n\n \n\n \n\n \n😊鸣谢\n@ipfgao:\n🔗训练步骤记录\n@chuanzhubin:\n🔗代码逐行注释\n@WangRongsheng:\n🔗大型数据集预处理\n@pengqianhan:\n🔗一个简明教程\n@RyanSunn:\n🔗推理过程学习记录\n\n 参考链接 & 感谢以下优秀的论文或项目 \n\n排名不分任何先后顺序\nhttps://github.com/meta-llama/llama3\nhttps://github.com/karpathy/llama2.c\nhttps://github.com/DLLXW/baby-llama2-chinese\n(DeepSeek-V2)https://arxiv.org/abs/2405.04434\nhttps://github.com/charent/ChatLM-mini-Chinese\nhttps://github.com/wdndev/tiny-llm-zh\n(Mistral-MoE)https://arxiv.org/pdf/2401.04088\nhttps://github.com/Tongjilibo/build_MiniLLM_from_scratch\nhttps://github.com/jzhang38/TinyLlama\nhttps://github.com/AI-Study-Han/Zero-Chatgpt\nhttps://github.com/xusenlinzy/api-for-open-llm\nhttps://github.com/HqWu-HITCS/Awesome-Chinese-LLM\n\n\n🫶支持者\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLicense\nThis repository is licensed under the Apache-2.0 License.",
      "languages": {
        "R": 1,
        "python": 1,
        "Python": 1
      },
      "topics": [
        "R",
        "Python"
      ],
      "stars": 0,
      "forks": 0,
      "last_updated": "2025-02-22T13:53:36.057692"
    },
    {
      "owner": "freqtrade",
      "name": "freqtrade",
      "url": "https://github.com/freqtrade/freqtrade",
      "description": "Free, open source crypto trading bot",
      "readme_content": "Freqtrade is a free and open source crypto trading bot written in Python. It is designed to support all major exchanges and be controlled via Telegram or webUI. It contains backtesting, plotting and money management tools as well as strategy optimization by machine learning.\n\nDisclaimer\nThis software is for educational purposes only. Do not risk money which\nyou are afraid to lose. USE THE SOFTWARE AT YOUR OWN RISK. THE AUTHORS\nAND ALL AFFILIATES ASSUME NO RESPONSIBILITY FOR YOUR TRADING RESULTS.\nAlways start by running a trading bot in Dry-run and do not engage money\nbefore you understand how it works and what profit/loss you should\nexpect.\nWe strongly recommend you to have coding and Python knowledge. Do not\nhesitate to read the source code and understand the mechanism of this bot.\nSupported Exchange marketplaces\nPlease read the exchange specific notes to learn about eventual, special configurations needed for each exchange.\n\n Binance\n Bitmart\n BingX\n Bybit\n Gate.io\n HTX\n Hyperliquid (A decentralized exchange, or DEX)\n Kraken\n OKX\n MyOKX (OKX EEA)\n potentially many others. (We cannot guarantee they will work)\n\nSupported Futures Exchanges (experimental)\n\n Binance\n Gate.io\n Hyperliquid (A decentralized exchange, or DEX)\n OKX\n Bybit\n\nPlease make sure to read the exchange specific notes, as well as the trading with leverage documentation before diving in.\nCommunity tested\nExchanges confirmed working by the community:\n\n Bitvavo\n Kucoin\n\nDocumentation\nWe invite you to read the bot documentation to ensure you understand how the bot is working.\nPlease find the complete documentation on the freqtrade website.\nFeatures\n\n Based on Python 3.10+: For botting on any operating system - Windows, macOS and Linux.\n Persistence: Persistence is achieved through sqlite.\n Dry-run: Run the bot without paying money.\n Backtesting: Run a simulation of your buy/sell strategy.\n Strategy Optimization by machine learning: Use machine learning to optimize your buy/sell strategy parameters with real exchange data.\n Adaptive prediction modeling: Build a smart strategy with FreqAI that self-trains to the market via adaptive machine learning methods. Learn more\n Edge position sizing Calculate your win rate, risk reward ratio, the best stoploss and adjust your position size before taking a position for each specific market. Learn more.\n Whitelist crypto-currencies: Select which crypto-currency you want to trade or use dynamic whitelists.\n Blacklist crypto-currencies: Select which crypto-currency you want to avoid.\n Builtin WebUI: Builtin web UI to manage your bot.\n Manageable via Telegram: Manage the bot with Telegram.\n Display profit/loss in fiat: Display your profit/loss in fiat currency.\n Performance status report: Provide a performance status of your current trades.\n\nQuick start\nPlease refer to the Docker Quickstart documentation on how to get started quickly.\nFor further (native) installation methods, please refer to the Installation documentation page.\nBasic Usage\nBot commands\nusage: freqtrade [-h] [-V]\n                 {trade,create-userdir,new-config,show-config,new-strategy,download-data,convert-data,convert-trade-data,trades-to-ohlcv,list-data,backtesting,backtesting-show,backtesting-analysis,edge,hyperopt,hyperopt-list,hyperopt-show,list-exchanges,list-markets,list-pairs,list-strategies,list-hyperoptloss,list-freqaimodels,list-timeframes,show-trades,test-pairlist,convert-db,install-ui,plot-dataframe,plot-profit,webserver,strategy-updater,lookahead-analysis,recursive-analysis}\n                 ...\n\nFree, open source crypto trading bot\n\npositional arguments:\n  {trade,create-userdir,new-config,show-config,new-strategy,download-data,convert-data,convert-trade-data,trades-to-ohlcv,list-data,backtesting,backtesting-show,backtesting-analysis,edge,hyperopt,hyperopt-list,hyperopt-show,list-exchanges,list-markets,list-pairs,list-strategies,list-hyperoptloss,list-freqaimodels,list-timeframes,show-trades,test-pairlist,convert-db,install-ui,plot-dataframe,plot-profit,webserver,strategy-updater,lookahead-analysis,recursive-analysis}\n    trade               Trade module.\n    create-userdir      Create user-data directory.\n    new-config          Create new config\n    show-config         Show resolved config\n    new-strategy        Create new strategy\n    download-data       Download backtesting data.\n    convert-data        Convert candle (OHLCV) data from one format to\n                        another.\n    convert-trade-data  Convert trade data from one format to another.\n    trades-to-ohlcv     Convert trade data to OHLCV data.\n    list-data           List downloaded data.\n    backtesting         Backtesting module.\n    backtesting-show    Show past Backtest results\n    backtesting-analysis\n                        Backtest Analysis module.\n    edge                Edge module.\n    hyperopt            Hyperopt module.\n    hyperopt-list       List Hyperopt results\n    hyperopt-show       Show details of Hyperopt results\n    list-exchanges      Print available exchanges.\n    list-markets        Print markets on exchange.\n    list-pairs          Print pairs on exchange.\n    list-strategies     Print available strategies.\n    list-hyperoptloss   Print available hyperopt loss functions.\n    list-freqaimodels   Print available freqAI models.\n    list-timeframes     Print available timeframes for the exchange.\n    show-trades         Show trades.\n    test-pairlist       Test your pairlist configuration.\n    convert-db          Migrate database to different system\n    install-ui          Install FreqUI\n    plot-dataframe      Plot candles with indicators.\n    plot-profit         Generate plot showing profits.\n    webserver           Webserver module.\n    strategy-updater    updates outdated strategy files to the current version\n    lookahead-analysis  Check for potential look ahead bias.\n    recursive-analysis  Check for potential recursive formula issue.\n\noptions:\n  -h, --help            show this help message and exit\n  -V, --version         show program's version number and exit\n\nTelegram RPC commands\nTelegram is not mandatory. However, this is a great way to control your bot. More details and the full command list on the documentation\n\n/start: Starts the trader.\n/stop: Stops the trader.\n/stopentry: Stop entering new trades.\n/status <trade_id>|[table]: Lists all or specific open trades.\n/profit [<n>]: Lists cumulative profit from all finished trades, over the last n days.\n/forceexit <trade_id>|all: Instantly exits the given trade (Ignoring minimum_roi).\n/fx <trade_id>|all: Alias to /forceexit\n/performance: Show performance of each finished trade grouped by pair\n/balance: Show account balance per currency.\n/daily <n>: Shows profit or loss per day, over the last n days.\n/help: Show help message.\n/version: Show version.\n\nDevelopment branches\nThe project is currently setup in two main branches:\n\ndevelop - This branch has often new features, but might also contain breaking changes. We try hard to keep this branch as stable as possible.\nstable - This branch contains the latest stable release. This branch is generally well tested.\nfeat/* - These are feature branches, which are being worked on heavily. Please don't use these unless you want to test a specific feature.\n\nSupport\nHelp / Discord\nFor any questions not covered by the documentation or for further information about the bot, or to simply engage with like-minded individuals, we encourage you to join the Freqtrade discord server.\nBugs / Issues\nIf you discover a bug in the bot, please\nsearch the issue tracker\nfirst. If it hasn't been reported, please\ncreate a new issue and\nensure you follow the template guide so that the team can assist you as\nquickly as possible.\nFor every issue created, kindly follow up and mark satisfaction or reminder to close issue when equilibrium ground is reached.\n--Maintain github's community policy--\nFeature Requests\nHave you a great idea to improve the bot you want to share? Please,\nfirst search if this feature was not already discussed.\nIf it hasn't been requested, please\ncreate a new request\nand ensure you follow the template guide so that it does not get lost\nin the bug reports.\nPull Requests\nFeel like the bot is missing a feature? We welcome your pull requests!\nPlease read the\nContributing document\nto understand the requirements before sending your pull-requests.\nCoding is not a necessity to contribute - maybe start with improving the documentation?\nIssues labeled good first issue can be good first contributions, and will help get you familiar with the codebase.\nNote before starting any major new feature work, please open an issue describing what you are planning to do or talk to us on discord (please use the #dev channel for this). This will ensure that interested parties can give valuable feedback on the feature, and let others know that you are working on it.\nImportant: Always create your PR against the develop branch, not stable.\nRequirements\nUp-to-date clock\nThe clock must be accurate, synchronized to a NTP server very frequently to avoid problems with communication to the exchanges.\nMinimum hardware required\nTo run this bot we recommend you a cloud instance with a minimum of:\n\nMinimal (advised) system requirements: 2GB RAM, 1GB disk space, 2vCPU\n\nSoftware requirements\n\nPython >= 3.10\npip\ngit\nTA-Lib\nvirtualenv (Recommended)\nDocker (Recommended)",
      "languages": {
        "python": 1,
        "Python": 1
      },
      "topics": [
        "Python",
        "Machine Learning",
        "Docker"
      ],
      "stars": 0,
      "forks": 0,
      "last_updated": "2025-02-22T13:53:36.784894"
    },
    {
      "owner": "microsoft",
      "name": "PIKE-RAG",
      "url": "https://github.com/microsoft/PIKE-RAG",
      "description": "PIKE-RAG: sPecIalized KnowledgE and Rationale Augmented Generation",
      "readme_content": "🌐Online Demo\n📊Technical Report\n\n\n\n\n\n\n\n\nPIKE-RAG: sPecIalized KnowledgE and Rationale Augmented Generation\nWhy PIKE-RAG?\nIn recent years, Retrieval Augmented Generation (RAG) systems have made significant progress in extending the capabilities of Large Language Models (LLM) through external retrieval. However, these systems still face challenges in meeting the complex and diverse needs of real-world industrial applications. Relying solely on direct retrieval is insufficient for extracting deep domain-specific knowledge from professional corpora and performing logical reasoning. To address this issue, we propose the PIKE-RAG (sPecIalized KnowledgE and Rationale Augmented Generation) method, which focuses on extracting, understanding, and applying domain-specific knowledge while building coherent reasoning logic to gradually guide LLMs toward accurate responses.\n\n\n\nPIKE-RAG framework mainly consists of several basic modules, including document parsing, knowledge extraction, knowledge storage, knowledge retrieval, knowledge organization, knowledge-centric reasoning, and task decomposition and coordination. By adjusting the submodules within the main modules, it is possible to achieve RAG systems that focus on different capabilities to meet the diverse needs of real-world scenarios.\nFor example, in case patient's historical medical records searching, it focuses on the factual information retrieval capability. The main challenges are that (1) the understanding and extraction of knowledge are often hindered by inappropriate knowledge segmentation, disrupting semantic coherence, leading to a complex and inefficient retrieval process; (2) commonly used embedding-based knowledge retrieval is limited by embedding models' ability to align professional terms and aliases, reducing system accuracy. With PIKE-RAG, we can improve the accuracy of knowledge extraction and retrieval by using context-aware segmentation techniques, automatic term label alignment techniques, and multi-granularity knowledge extraction methods during the knowledge extraction process, thereby enhancing factual information retrieval capability, as shown in the pipeline below.\n\n\n\nFor complex task like reasonable treatment plans and coping measures suggestions for patients, it requires more advanced capabilities: strong domain-specific knowledge are required to accurately understand the task and sometimes reasonably decompose it; advanced data retrieval, processing and organization techniques are also required for potential tendency prediction; while multi-agents planning will also be useful to take considerations of both creativity and reliance. In such case, a richer pipeline below can be initialized to achieve this.\n\n\n\nIn public benchmark tests, PIKE-RAG demonstrated excellent performance on several multi-hop question answering datasets such as HotpotQA, 2WikiMultiHopQA, and MuSiQue. Compared to existing benchmark methods, PIKE-RAG excelled in metrics like accuracy and F1 score. On the HotpotQA dataset, PIKE-RAG achieved an accuracy of 87.6%, on 2WikiMultiHopQA it reached 82.0%, and on the more challenging MuSiQue dataset, it achieved 59.6%. These results indicate that PIKE-RAG has significant advantages in handling complex reasoning tasks, especially in scenarios that require integrating multi-source information and performing multi-step reasoning.\nPIKE-RAG has been tested and significantly improved question answering accuracy in fields such as industrial manufacturing, mining, and pharmaceuticals. In the future, we will continue to explore its application in more fields. Additionally, we will continue to explore other forms of knowledge and logic and their optimal adaptation to specific scenarios.\nFor More Details\n\n📊 Technical Report will illustrate the industrial RAG problem classification, introduce the main components in PIKE-RAG, and show some experimental results in public benchmarks.\n🌐 Online Demo is a show-case of our Knowledge-Aware decomposition pipeline for L2 RAG task.\n\nQuick Start\n\nClone this repo and set up the Python environment, refer to this document;\nCreate a .env file to save your endpoint information (and some other environment variables if needed), refer to this document;\nModify the yaml config files and try the scripts under examples/, refer to this document;\nBuild up your own pipeline and/or add your own components!\n\nContributing\nThis project welcomes contributions and suggestions.  Most contributions require you to agree to a\nContributor License Agreement (CLA) declaring that you have the right to, and actually do, grant us\nthe rights to use your contribution. For details, visit https://cla.opensource.microsoft.com.\nWhen you submit a pull request, a CLA bot will automatically determine whether you need to provide\na CLA and decorate the PR appropriately (e.g., status check, comment). Simply follow the instructions\nprovided by the bot. You will only need to do this once across all repos using our CLA.\nThis project has adopted the Microsoft Open Source Code of Conduct.\nFor more information see the Code of Conduct FAQ or\ncontact opencode@microsoft.com with any additional questions or comments.\nTrademarks\nThis project may contain trademarks or logos for projects, products, or services. Authorized use of Microsoft\ntrademarks or logos is subject to and must follow\nMicrosoft's Trademark & Brand Guidelines.\nUse of Microsoft trademarks or logos in modified versions of this project must not cause confusion or imply Microsoft sponsorship.\nAny use of third-party trademarks or logos are subject to those third-party's policies.",
      "languages": {
        "python": 1,
        "Python": 1
      },
      "topics": [
        "Python"
      ],
      "stars": 0,
      "forks": 0,
      "last_updated": "2025-02-22T13:53:37.578581"
    },
    {
      "owner": "comfyanonymous",
      "name": "ComfyUI",
      "url": "https://github.com/comfyanonymous/ComfyUI",
      "description": "The most powerful and modular diffusion model GUI, api and backend with a graph/nodes interface.",
      "readme_content": "ComfyUI\nThe most powerful and modular diffusion model GUI and backend.\n\n\n\n\n\n\n\n\n\n\nThis ui will let you design and execute advanced stable diffusion pipelines using a graph/nodes/flowchart based interface. For some workflow examples and see what ComfyUI can do you can check out:\nComfyUI Examples\nInstalling ComfyUI\nFeatures\n\nNodes/graph/flowchart interface to experiment and create complex Stable Diffusion workflows without needing to code anything.\nImage Models\n\nSD1.x, SD2.x,\nSDXL, SDXL Turbo\nStable Cascade\nSD3 and SD3.5\nPixart Alpha and Sigma\nAuraFlow\nHunyuanDiT\nFlux\nLumina Image 2.0\n\n\nVideo Models\n\nStable Video Diffusion\nMochi\nLTX-Video\nHunyuan Video\nNvidia Cosmos\n\n\nStable Audio\nAsynchronous Queue system\nMany optimizations: Only re-executes the parts of the workflow that changes between executions.\nSmart memory management: can automatically run models on GPUs with as low as 1GB vram.\nWorks even if you don't have a GPU with: --cpu (slow)\nCan load ckpt, safetensors and diffusers models/checkpoints. Standalone VAEs and CLIP models.\nEmbeddings/Textual inversion\nLoras (regular, locon and loha)\nHypernetworks\nLoading full workflows (with seeds) from generated PNG, WebP and FLAC files.\nSaving/Loading workflows as Json files.\nNodes interface can be used to create complex workflows like one for Hires fix or much more advanced ones.\nArea Composition\nInpainting with both regular and inpainting models.\nControlNet and T2I-Adapter\nUpscale Models (ESRGAN, ESRGAN variants, SwinIR, Swin2SR, etc...)\nunCLIP Models\nGLIGEN\nModel Merging\nLCM models and Loras\nLatent previews with TAESD\nStarts up very fast.\nWorks fully offline: will never download anything.\nConfig file to set the search paths for models.\n\nWorkflow examples can be found on the Examples page\nShortcuts\n\n\n\nKeybind\nExplanation\n\n\n\n\nCtrl + Enter\nQueue up current graph for generation\n\n\nCtrl + Shift + Enter\nQueue up current graph as first for generation\n\n\nCtrl + Alt + Enter\nCancel current generation\n\n\nCtrl + Z/Ctrl + Y\nUndo/Redo\n\n\nCtrl + S\nSave workflow\n\n\nCtrl + O\nLoad workflow\n\n\nCtrl + A\nSelect all nodes\n\n\nAlt + C\nCollapse/uncollapse selected nodes\n\n\nCtrl + M\nMute/unmute selected nodes\n\n\nCtrl + B\nBypass selected nodes (acts like the node was removed from the graph and the wires reconnected through)\n\n\nDelete/Backspace\nDelete selected nodes\n\n\nCtrl + Backspace\nDelete the current graph\n\n\nSpace\nMove the canvas around when held and moving the cursor\n\n\nCtrl/Shift + Click\nAdd clicked node to selection\n\n\nCtrl + C/Ctrl + V\nCopy and paste selected nodes (without maintaining connections to outputs of unselected nodes)\n\n\nCtrl + C/Ctrl + Shift + V\nCopy and paste selected nodes (maintaining connections from outputs of unselected nodes to inputs of pasted nodes)\n\n\nShift + Drag\nMove multiple selected nodes at the same time\n\n\nCtrl + D\nLoad default graph\n\n\nAlt + +\nCanvas Zoom in\n\n\nAlt + -\nCanvas Zoom out\n\n\nCtrl + Shift + LMB + Vertical drag\nCanvas Zoom in/out\n\n\nP\nPin/Unpin selected nodes\n\n\nCtrl + G\nGroup selected nodes\n\n\nQ\nToggle visibility of the queue\n\n\nH\nToggle visibility of history\n\n\nR\nRefresh graph\n\n\nF\nShow/Hide menu\n\n\n.\nFit view to selection (Whole graph when nothing is selected)\n\n\nDouble-Click LMB\nOpen node quick search palette\n\n\nShift + Drag\nMove multiple wires at once\n\n\nCtrl + Alt + LMB\nDisconnect all wires from clicked slot\n\n\n\nCtrl can also be replaced with Cmd instead for macOS users\nInstalling\nWindows\nThere is a portable standalone build for Windows that should work for running on Nvidia GPUs or for running on your CPU only on the releases page.\nDirect link to download\nSimply download, extract with 7-Zip and run. Make sure you put your Stable Diffusion checkpoints/models (the huge ckpt/safetensors files) in: ComfyUI\\models\\checkpoints\nIf you have trouble extracting it, right click the file -> properties -> unblock\nIf you have a 50 series Blackwell card like a 5090 or 5080 see this discussion thread\nHow do I share models between another UI and ComfyUI?\nSee the Config file to set the search paths for models. In the standalone windows build you can find this file in the ComfyUI directory. Rename this file to extra_model_paths.yaml and edit it with your favorite text editor.\nJupyter Notebook\nTo run it on services like paperspace, kaggle or colab you can use my Jupyter Notebook\nManual Install (Windows, Linux)\npython 3.13 is supported but using 3.12 is recommended because some custom nodes and their dependencies might not support it yet.\nGit clone this repo.\nPut your SD checkpoints (the huge ckpt/safetensors files) in: models/checkpoints\nPut your VAE in: models/vae\nAMD GPUs (Linux only)\nAMD users can install rocm and pytorch with pip if you don't have it already installed, this is the command to install the stable version:\npip install torch torchvision torchaudio --index-url https://download.pytorch.org/whl/rocm6.2.4\nThis is the command to install the nightly with ROCm 6.3 which might have some performance improvements:\npip install --pre torch torchvision torchaudio --index-url https://download.pytorch.org/whl/nightly/rocm6.3\nIntel GPUs (Windows and Linux)\n(Option 1) Intel Arc GPU users can install native PyTorch with torch.xpu support using pip (currently available in PyTorch nightly builds). More information can be found here\n\nTo install PyTorch nightly, use the following command:\n\npip install --pre torch torchvision torchaudio --index-url https://download.pytorch.org/whl/nightly/xpu\n\nLaunch ComfyUI by running python main.py\n\n(Option 2) Alternatively, Intel GPUs supported by Intel Extension for PyTorch (IPEX) can leverage IPEX for improved performance.\n\nFor Intel® Arc™ A-Series Graphics utilizing IPEX, create a conda environment and use the commands below:\n\nconda install libuv\npip install torch==2.3.1.post0+cxx11.abi torchvision==0.18.1.post0+cxx11.abi torchaudio==2.3.1.post0+cxx11.abi intel-extension-for-pytorch==2.3.110.post0+xpu --extra-index-url https://pytorch-extension.intel.com/release-whl/stable/xpu/us/ --extra-index-url https://pytorch-extension.intel.com/release-whl/stable/xpu/cn/\n\nFor other supported Intel GPUs with IPEX, visit Installation for more information.\nAdditional discussion and help can be found here.\nNVIDIA\nNvidia users should install stable pytorch using this command:\npip install torch torchvision torchaudio --extra-index-url https://download.pytorch.org/whl/cu126\nThis is the command to install pytorch nightly instead which might have performance improvements:\npip install --pre torch torchvision torchaudio --index-url https://download.pytorch.org/whl/nightly/cu126\nTroubleshooting\nIf you get the \"Torch not compiled with CUDA enabled\" error, uninstall torch with:\npip uninstall torch\nAnd install it again with the command above.\nDependencies\nInstall the dependencies by opening your terminal inside the ComfyUI folder and:\npip install -r requirements.txt\nAfter this you should have everything installed and can proceed to running ComfyUI.\nOthers:\nApple Mac silicon\nYou can install ComfyUI in Apple Mac silicon (M1 or M2) with any recent macOS version.\n\nInstall pytorch nightly. For instructions, read the Accelerated PyTorch training on Mac Apple Developer guide (make sure to install the latest pytorch nightly).\nFollow the ComfyUI manual installation instructions for Windows and Linux.\nInstall the ComfyUI dependencies. If you have another Stable Diffusion UI you might be able to reuse the dependencies.\nLaunch ComfyUI by running python main.py\n\n\nNote: Remember to add your models, VAE, LoRAs etc. to the corresponding Comfy folders, as discussed in ComfyUI manual installation.\n\nDirectML (AMD Cards on Windows)\npip install torch-directml Then you can launch ComfyUI with: python main.py --directml\nAscend NPUs\nFor models compatible with Ascend Extension for PyTorch (torch_npu). To get started, ensure your environment meets the prerequisites outlined on the installation page. Here's a step-by-step guide tailored to your platform and installation method:\n\nBegin by installing the recommended or newer kernel version for Linux as specified in the Installation page of torch-npu, if necessary.\nProceed with the installation of Ascend Basekit, which includes the driver, firmware, and CANN, following the instructions provided for your specific platform.\nNext, install the necessary packages for torch-npu by adhering to the platform-specific instructions on the Installation page.\nFinally, adhere to the ComfyUI manual installation guide for Linux. Once all components are installed, you can run ComfyUI as described earlier.\n\nRunning\npython main.py\nFor AMD cards not officially supported by ROCm\nTry running it with this command if you have issues:\nFor 6700, 6600 and maybe other RDNA2 or older: HSA_OVERRIDE_GFX_VERSION=10.3.0 python main.py\nFor AMD 7600 and maybe other RDNA3 cards: HSA_OVERRIDE_GFX_VERSION=11.0.0 python main.py\nAMD ROCm Tips\nYou can enable experimental memory efficient attention on pytorch 2.5 in ComfyUI on RDNA3 and potentially other AMD GPUs using this command:\nTORCH_ROCM_AOTRITON_ENABLE_EXPERIMENTAL=1 python main.py --use-pytorch-cross-attention\nYou can also try setting this env variable PYTORCH_TUNABLEOP_ENABLED=1 which might speed things up at the cost of a very slow initial run.\nNotes\nOnly parts of the graph that have an output with all the correct inputs will be executed.\nOnly parts of the graph that change from each execution to the next will be executed, if you submit the same graph twice only the first will be executed. If you change the last part of the graph only the part you changed and the part that depends on it will be executed.\nDragging a generated png on the webpage or loading one will give you the full workflow including seeds that were used to create it.\nYou can use () to change emphasis of a word or phrase like: (good code:1.2) or (bad code:0.8). The default emphasis for () is 1.1. To use () characters in your actual prompt escape them like \\( or \\).\nYou can use {day|night}, for wildcard/dynamic prompts. With this syntax \"{wild|card|test}\" will be randomly replaced by either \"wild\", \"card\" or \"test\" by the frontend every time you queue the prompt. To use {} characters in your actual prompt escape them like: \\{ or \\}.\nDynamic prompts also support C-style comments, like // comment or /* comment */.\nTo use a textual inversion concepts/embeddings in a text prompt put them in the models/embeddings directory and use them in the CLIPTextEncode node like this (you can omit the .pt extension):\nembedding:embedding_filename.pt\nHow to show high-quality previews?\nUse --preview-method auto to enable previews.\nThe default installation includes a fast latent preview method that's low-resolution. To enable higher-quality previews with TAESD, download the taesd_decoder.pth, taesdxl_decoder.pth, taesd3_decoder.pth and taef1_decoder.pth and place them in the models/vae_approx folder. Once they're installed, restart ComfyUI and launch it with --preview-method taesd to enable high-quality previews.\nHow to use TLS/SSL?\nGenerate a self-signed certificate (not appropriate for shared/production use) and key by running the command: openssl req -x509 -newkey rsa:4096 -keyout key.pem -out cert.pem -sha256 -days 3650 -nodes -subj \"/C=XX/ST=StateName/L=CityName/O=CompanyName/OU=CompanySectionName/CN=CommonNameOrHostname\"\nUse --tls-keyfile key.pem --tls-certfile cert.pem to enable TLS/SSL, the app will now be accessible with https://... instead of http://....\n\nNote: Windows users can use alexisrolland/docker-openssl or one of the 3rd party binary distributions to run the command example above.\nIf you use a container, note that the volume mount -v can be a relative path so ... -v \".\\:/openssl-certs\" ... would create the key & cert files in the current directory of your command prompt or powershell terminal.\n\nSupport and dev channel\nDiscord: Try the #help or #feedback channels.\nMatrix space: #comfyui_space:matrix.org (it's like discord but open source).\nSee also: https://www.comfy.org/\nFrontend Development\nAs of August 15, 2024, we have transitioned to a new frontend, which is now hosted in a separate repository: ComfyUI Frontend. This repository now hosts the compiled JS (from TS/Vue) under the web/ directory.\nReporting Issues and Requesting Features\nFor any bugs, issues, or feature requests related to the frontend, please use the ComfyUI Frontend repository. This will help us manage and address frontend-specific concerns more efficiently.\nUsing the Latest Frontend\nThe new frontend is now the default for ComfyUI. However, please note:\n\nThe frontend in the main ComfyUI repository is updated fortnightly.\nDaily releases are available in the separate frontend repository.\n\nTo use the most up-to-date frontend version:\n\n\nFor the latest daily release, launch ComfyUI with this command line argument:\n--front-end-version Comfy-Org/ComfyUI_frontend@latest\n\n\n\nFor a specific version, replace latest with the desired version number:\n--front-end-version Comfy-Org/ComfyUI_frontend@1.2.2\n\n\n\nThis approach allows you to easily switch between the stable fortnightly release and the cutting-edge daily updates, or even specific versions for testing purposes.\nAccessing the Legacy Frontend\nIf you need to use the legacy frontend for any reason, you can access it using the following command line argument:\n--front-end-version Comfy-Org/ComfyUI_legacy_frontend@latest\n\nThis will use a snapshot of the legacy frontend preserved in the ComfyUI Legacy Frontend repository.\nQA\nWhich GPU should I buy for this?\nSee this page for some recommendations",
      "languages": {
        "R": 1,
        "python": 1,
        "Python": 1
      },
      "topics": [
        "Python",
        "Frontend Development",
        "R",
        "Docker"
      ],
      "stars": 0,
      "forks": 0,
      "last_updated": "2025-02-22T13:53:38.309006"
    },
    {
      "owner": "exo-explore",
      "name": "exo",
      "url": "https://github.com/exo-explore/exo",
      "description": "Run your own AI cluster at home with everyday devices 📱💻 🖥️⌚",
      "readme_content": "exo: Run your own AI cluster at home with everyday devices. Maintained by exo labs.\n\nDiscord | Telegram | X\n\n\n\n\n\n\n\nUnify your existing devices into one powerful GPU: iPhone, iPad, Android, Mac, NVIDIA, Raspberry Pi, pretty much any device!\n\nUpdate: exo is hiring. See here for more details.\nInterested in running exo in your business? Contact us to discuss.\n\nGet Involved\nexo is experimental software. Expect bugs early on. Create issues so they can be fixed. The exo labs team will strive to resolve issues quickly.\nWe also welcome contributions from the community. We have a list of bounties in this sheet.\nFeatures\nWide Model Support\nexo supports different models including LLaMA (MLX and tinygrad), Mistral, LlaVA, Qwen, and Deepseek.\nDynamic Model Partitioning\nexo optimally splits up models based on the current network topology and device resources available. This enables you to run larger models than you would be able to on any single device.\nAutomatic Device Discovery\nexo will automatically discover other devices using the best method available. Zero manual configuration.\nChatGPT-compatible API\nexo provides a ChatGPT-compatible API for running models. It's a one-line change in your application to run models on your own hardware using exo.\nDevice Equality\nUnlike other distributed inference frameworks, exo does not use a master-worker architecture. Instead, exo devices connect p2p. As long as a device is connected somewhere in the network, it can be used to run models.\nExo supports different partitioning strategies to split up a model across devices. The default partitioning strategy is ring memory weighted partitioning. This runs an inference in a ring where each device runs a number of model layers proportional to the memory of the device.\n\nInstallation\nThe current recommended way to install exo is from source.\nPrerequisites\n\nPython>=3.12.0 is required because of issues with asyncio in previous versions.\nFor Linux with NVIDIA GPU support (Linux-only, skip if not using Linux or NVIDIA):\n\nNVIDIA driver - verify with nvidia-smi\nCUDA toolkit - install from NVIDIA CUDA guide, verify with nvcc --version\ncuDNN library - download from NVIDIA cuDNN page, verify installation by following these steps\n\n\n\nHardware Requirements\n\nThe only requirement to run exo is to have enough memory across all your devices to fit the entire model into memory. For example, if you are running llama 3.1 8B (fp16), you need 16GB of memory across all devices. Any of the following configurations would work since they each have more than 16GB of memory in total:\n\n2 x 8GB M3 MacBook Airs\n1 x 16GB NVIDIA RTX 4070 Ti Laptop\n2 x Raspberry Pi 400 with 4GB of RAM each (running on CPU) + 1 x 8GB Mac Mini\n\n\nexo is designed to run on devices with heterogeneous capabilities. For example, you can have some devices with powerful GPUs and others with integrated GPUs or even CPUs. Adding less capable devices will slow down individual inference latency but will increase the overall throughput of the cluster.\n\nFrom source\ngit clone https://github.com/exo-explore/exo.git\ncd exo\npip install -e .\n# alternatively, with venv\nsource install.sh\nTroubleshooting\n\nIf running on Mac, MLX has an install guide with troubleshooting steps.\n\nPerformance\n\nThere are a number of things users have empirically found to improve performance on Apple Silicon Macs:\n\n\nUpgrade to the latest version of macOS Sequoia.\nRun ./configure_mlx.sh. This runs commands to optimize GPU memory allocation on Apple Silicon Macs.\n\nDocumentation\nExample Usage on Multiple macOS Devices\nDevice 1:\nexo\nDevice 2:\nexo\nThat's it! No configuration required - exo will automatically discover the other device(s).\nexo starts a ChatGPT-like WebUI (powered by tinygrad tinychat) on http://localhost:52415\nFor developers, exo also starts a ChatGPT-compatible API endpoint on http://localhost:52415/v1/chat/completions. Examples with curl:\nLlama 3.2 3B:\ncurl http://localhost:52415/v1/chat/completions \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n     \"model\": \"llama-3.2-3b\",\n     \"messages\": [{\"role\": \"user\", \"content\": \"What is the meaning of exo?\"}],\n     \"temperature\": 0.7\n   }'\nLlama 3.1 405B:\ncurl http://localhost:52415/v1/chat/completions \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n     \"model\": \"llama-3.1-405b\",\n     \"messages\": [{\"role\": \"user\", \"content\": \"What is the meaning of exo?\"}],\n     \"temperature\": 0.7\n   }'\nDeepSeek R1 (full 671B):\ncurl http://localhost:52415/v1/chat/completions \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n     \"model\": \"deepseek-r1\",\n     \"messages\": [{\"role\": \"user\", \"content\": \"What is the meaning of exo?\"}],\n     \"temperature\": 0.7\n   }'\nLlava 1.5 7B (Vision Language Model):\ncurl http://localhost:52415/v1/chat/completions \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n     \"model\": \"llava-1.5-7b-hf\",\n     \"messages\": [\n      {\n        \"role\": \"user\",\n        \"content\": [\n          {\n            \"type\": \"text\",\n            \"text\": \"What are these?\"\n          },\n          {\n            \"type\": \"image_url\",\n            \"image_url\": {\n              \"url\": \"http://images.cocodataset.org/val2017/000000039769.jpg\"\n            }\n          }\n        ]\n      }\n    ],\n     \"temperature\": 0.0\n   }'\nExample Usage on Multiple Heterogenous Devices (macOS + Linux)\nDevice 1 (macOS):\nexo\nNote: We don't need to explicitly tell exo to use the tinygrad inference engine. MLX and tinygrad are interoperable!\nDevice 2 (Linux):\nexo\nLinux devices will automatically default to using the tinygrad inference engine.\nYou can read about tinygrad-specific env vars here. For example, you can configure tinygrad to use the cpu by specifying CLANG=1.\nExample Usage on a single device with \"exo run\" command\nexo run llama-3.2-3b\nWith a custom prompt:\nexo run llama-3.2-3b --prompt \"What is the meaning of exo?\"\nModel Storage\nModels by default are stored in ~/.cache/exo/downloads.\nYou can set a different model storage location by setting the EXO_HOME env var.\nModel Downloading\nModels are downloaded from Hugging Face. If you are running exo in a country with strict internet censorship, you may need to download the models manually and put them in the ~/.cache/exo/downloads directory.\nTo download models from a proxy endpoint, set the HF_ENDPOINT environment variable. For example, to run exo with the huggingface mirror endpoint:\nHF_ENDPOINT=https://hf-mirror.com exo\nDebugging\nEnable debug logs with the DEBUG environment variable (0-9).\nDEBUG=9 exo\nFor the tinygrad inference engine specifically, there is a separate DEBUG flag TINYGRAD_DEBUG that can be used to enable debug logs (1-6).\nTINYGRAD_DEBUG=2 exo\nFormatting\nWe use yapf to format the code. To format the code, first install the formatting requirements:\npip3 install -e '.[formatting]'\nThen run the formatting script:\npython3 format.py ./exo\nKnown Issues\n\nOn certain versions of Python on macOS, certificates may not installed correctly, potentially causing SSL errors (e.g., when accessing huggingface.co). To resolve this, run the Install Certificates command, typicall as follows:\n\n/Applications/Python 3.x/Install Certificates.command\n\n🚧 As the library is evolving so quickly, the iOS implementation has fallen behind Python. We have decided for now not to put out the buggy iOS version and receive a bunch of GitHub issues for outdated code. We are working on solving this properly and will make an announcement when it's ready. If you would like access to the iOS implementation now, please email alex@exolabs.net with your GitHub username explaining your use-case and you will be granted access on GitHub.\n\nInference Engines\nexo supports the following inference engines:\n\n✅ MLX\n✅ tinygrad\n🚧 PyTorch\n🚧 llama.cpp\n\nDiscovery Modules\n\n✅ UDP\n✅ Manual\n✅ Tailscale\n🚧 Radio\n🚧 Bluetooth\n\nPeer Networking Modules\n\n✅ GRPC\n🚧 NCCL",
      "languages": {
        "python": 1,
        "Python": 1
      },
      "topics": [
        "gRPC",
        "Python"
      ],
      "stars": 0,
      "forks": 0,
      "last_updated": "2025-02-22T13:53:39.072221"
    },
    {
      "owner": "Qiskit",
      "name": "qiskit",
      "url": "https://github.com/Qiskit/qiskit",
      "description": "Qiskit is an open-source SDK for working with quantum computers at the level of extended quantum circuits, operators, and primitives.",
      "readme_content": "Qiskit\n\n\n\n\n\n\n\n\nQiskit  is an open-source SDK for working with quantum computers at the level of extended quantum circuits, operators, and primitives.\nThis library is the core component of Qiskit, which contains the building blocks for creating and working with quantum circuits, quantum operators, and primitive functions (Sampler and Estimator).\nIt also contains a transpiler that supports optimizing quantum circuits, and a quantum information toolbox for creating advanced operators.\nFor more details on how to use Qiskit, refer to the documentation located here:\nhttps://docs.quantum.ibm.com/\nInstallation\nWe encourage installing Qiskit via pip:\npip install qiskit\nPip will handle all dependencies automatically and you will always install the latest (and well-tested) version.\nTo install from source, follow the instructions in the documentation.\nCreate your first quantum program in Qiskit\nNow that Qiskit is installed, it's time to begin working with Qiskit. The essential parts of a quantum program are:\n\nDefine and build a quantum circuit that represents the quantum state\nDefine the classical output by measurements or a set of observable operators\nDepending on the output, use the Sampler primitive to sample outcomes or the Estimator primitive to estimate expectation values.\n\nCreate an example quantum circuit using the QuantumCircuit class:\nimport numpy as np\nfrom qiskit import QuantumCircuit\n\n# 1. A quantum circuit for preparing the quantum state |000> + i |111> / √2\nqc = QuantumCircuit(3)\nqc.h(0)             # generate superposition\nqc.p(np.pi / 2, 0)  # add quantum phase\nqc.cx(0, 1)         # 0th-qubit-Controlled-NOT gate on 1st qubit\nqc.cx(0, 2)         # 0th-qubit-Controlled-NOT gate on 2nd qubit\nThis simple example creates an entangled state known as a GHZ state $(|000\\rangle + i|111\\rangle)/\\sqrt{2}$. It uses the standard quantum gates: Hadamard gate (h), Phase gate (p), and CNOT gate (cx).\nOnce you've made your first quantum circuit, choose which primitive you will use. Starting with the Sampler,\nwe use measure_all(inplace=False) to get a copy of the circuit in which all the qubits are measured:\n# 2. Add the classical output in the form of measurement of all qubits\nqc_measured = qc.measure_all(inplace=False)\n\n# 3. Execute using the Sampler primitive\nfrom qiskit.primitives import StatevectorSampler\nsampler = StatevectorSampler()\njob = sampler.run([qc_measured], shots=1000)\nresult = job.result()\nprint(f\" > Counts: {result[0].data[\"meas\"].get_counts()}\")\nRunning this will give an outcome similar to {'000': 497, '111': 503} which is 000 50% of the time and 111 50% of the time up to statistical fluctuations.\nTo illustrate the power of the Estimator, we now use the quantum information toolbox to create the operator $XXY+XYX+YXX-YYY$ and pass it to the run() function, along with our quantum circuit. Note that the Estimator requires a circuit without measurements, so we use the qc circuit we created earlier.\n# 2. Define the observable to be measured \nfrom qiskit.quantum_info import SparsePauliOp\noperator = SparsePauliOp.from_list([(\"XXY\", 1), (\"XYX\", 1), (\"YXX\", 1), (\"YYY\", -1)])\n\n# 3. Execute using the Estimator primitive\nfrom qiskit.primitives import StatevectorEstimator\nestimator = StatevectorEstimator()\njob = estimator.run([(qc, operator)], precision=1e-3)\nresult = job.result()\nprint(f\" > Expectation values: {result[0].data.evs}\")\nRunning this will give the outcome 4. For fun, try to assign a value of +/- 1 to each single-qubit operator X and Y\nand see if you can achieve this outcome. (Spoiler alert: this is not possible!)\nUsing the Qiskit-provided qiskit.primitives.StatevectorSampler and qiskit.primitives.StatevectorEstimator will not take you very far.\nThe power of quantum computing cannot be simulated on classical computers and you need to use real quantum hardware to scale to larger quantum circuits.\nHowever, running a quantum circuit on hardware requires rewriting to the basis gates and connectivity of the quantum hardware.\nThe tool that does this is the transpiler, and Qiskit includes transpiler passes for synthesis, optimization, mapping, and scheduling.\nHowever, it also includes a default compiler, which works very well in most examples.\nThe following code will map the example circuit to the basis_gates = [\"cz\", \"sx\", \"rz\"] and a linear chain of qubits $0 \\rightarrow 1 \\rightarrow 2$ with the coupling_map = [[0, 1], [1, 2]].\nfrom qiskit import transpile\nqc_transpiled = transpile(qc, basis_gates=[\"cz\", \"sx\", \"rz\"], coupling_map=[[0, 1], [1, 2]], optimization_level=3)\nExecuting your code on real quantum hardware\nQiskit provides an abstraction layer that lets users run quantum circuits on hardware from any vendor that provides a compatible interface.\nThe best way to use Qiskit is with a runtime environment that provides optimized implementations of Sampler and Estimator for a given hardware platform. This runtime may involve using pre- and post-processing, such as optimized transpiler passes with error suppression, error mitigation, and, eventually, error correction built in. A runtime implements qiskit.primitives.BaseSamplerV2 and qiskit.primitives.BaseEstimatorV2 interfaces. For example,\nsome packages that provide implementations of a runtime primitive implementation are:\n\nhttps://github.com/Qiskit/qiskit-ibm-runtime\n\nQiskit also provides a lower-level abstract interface for describing quantum backends. This interface, located in\nqiskit.providers, defines an abstract BackendV2 class that providers can implement to represent their\nhardware or simulators to Qiskit. The backend class includes a common interface for executing circuits on the backends; however, in this interface each provider may perform different types of pre- and post-processing and return outcomes that are vendor-defined. Some examples of published provider packages that interface with real hardware are:\n\nhttps://github.com/qiskit-community/qiskit-ionq\nhttps://github.com/qiskit-community/qiskit-aqt-provider\nhttps://github.com/qiskit-community/qiskit-braket-provider\nhttps://github.com/qiskit-community/qiskit-quantinuum-provider\nhttps://github.com/rigetti/qiskit-rigetti\n\nYou can refer to the documentation of these packages for further instructions\non how to get access and use these systems.\nContribution Guidelines\nIf you'd like to contribute to Qiskit, please take a look at our\ncontribution guidelines. By participating, you are expected to uphold our code of conduct.\nWe use GitHub issues for tracking requests and bugs. Please\njoin the Qiskit Slack community for discussion, comments, and questions.\nFor questions related to running or using Qiskit, Stack Overflow has a qiskit.\nFor questions on quantum computing with Qiskit, use the qiskit tag in the Quantum Computing Stack Exchange (please, read first the guidelines on how to ask in that forum).\nAuthors and Citation\nQiskit is the work of many people who contribute\nto the project at different levels. If you use Qiskit, please cite as per the included BibTeX file.\nChangelog and Release Notes\nThe changelog for a particular release is dynamically generated and gets\nwritten to the release page on Github for each release. For example, you can\nfind the page for the 1.2.0 release here:\nhttps://github.com/Qiskit/qiskit/releases/tag/1.2.0\nThe changelog for the current release can be found in the releases tab:\n\nThe changelog provides a quick overview of notable changes for a given\nrelease.\nAdditionally, as part of each release, detailed release notes are written to\ndocument in detail what has changed as part of a release. This includes any\ndocumentation on potential breaking changes on upgrade and new features. See all release notes here.\nAcknowledgements\nWe acknowledge partial support for Qiskit development from the DOE Office of Science National Quantum Information Science Research Centers, Co-design Center for Quantum Advantage (C2QA) under contract number DE-SC0012704.\nLicense\nApache License 2.0",
      "languages": {},
      "topics": [],
      "stars": 0,
      "forks": 0,
      "last_updated": "2025-02-22T13:53:40.206799"
    },
    {
      "owner": "blacklanternsecurity",
      "name": "bbot",
      "url": "https://github.com/blacklanternsecurity/bbot",
      "description": "The recursive internet scanner for hackers. 🧡",
      "readme_content": "BEE·bot is a multipurpose scanner inspired by Spiderfoot, built to automate your Recon, Bug Bounties, and ASM!\n\n\n\n\n\nfirst-bbot-scan.mp4\n\n\n\n\n\nA BBOT scan in real-time - visualization with VivaGraphJS\nInstallation\n# stable version\npipx install bbot\n\n# bleeding edge (dev branch)\npipx install --pip-args '\\--pre' bbot\nFor more installation methods, including Docker, see Getting Started\nExample Commands\n1) Subdomain Finder\nPassive API sources plus a recursive DNS brute-force with target-specific subdomain mutations.\n# find subdomains of evilcorp.com\nbbot -t evilcorp.com -p subdomain-enum\n\n# passive sources only\nbbot -t evilcorp.com -p subdomain-enum -rf passive\n\nsubdomain-enum.yml\ndescription: Enumerate subdomains via APIs, brute-force\n\nflags:\n  # enable every module with the subdomain-enum flag\n  - subdomain-enum\n\noutput_modules:\n  # output unique subdomains to TXT file\n  - subdomains\n\nconfig:\n  dns:\n    threads: 25\n    brute_threads: 1000\n  # put your API keys here\n  # modules:\n  #   github:\n  #     api_key: \"\"\n  #   chaos:\n  #     api_key: \"\"\n  #   securitytrails:\n  #     api_key: \"\"\n\n\nBBOT consistently finds 20-50% more subdomains than other tools. The bigger the domain, the bigger the difference. To learn how this is possible, see How It Works.\n\n2) Web Spider\n# crawl evilcorp.com, extracting emails and other goodies\nbbot -t evilcorp.com -p spider\n\nspider.yml\ndescription: Recursive web spider\n\nmodules:\n  - httpx\n\nblacklist:\n  # Prevent spider from invalidating sessions by logging out\n  - \"RE:/.*(sign|log)[_-]?out\"\n\nconfig:\n  web:\n    # how many links to follow in a row\n    spider_distance: 2\n    # don't follow links whose directory depth is higher than 4\n    spider_depth: 4\n    # maximum number of links to follow per page\n    spider_links_per_page: 25\n\n\n3) Email Gatherer\n# quick email enum with free APIs + scraping\nbbot -t evilcorp.com -p email-enum\n\n# pair with subdomain enum + web spider for maximum yield\nbbot -t evilcorp.com -p email-enum subdomain-enum spider\n\nemail-enum.yml\ndescription: Enumerate email addresses from APIs, web crawling, etc.\n\nflags:\n  - email-enum\n\noutput_modules:\n  - emails\n\n\n4) Web Scanner\n# run a light web scan against www.evilcorp.com\nbbot -t www.evilcorp.com -p web-basic\n\n# run a heavy web scan against www.evilcorp.com\nbbot -t www.evilcorp.com -p web-thorough\n\nweb-basic.yml\ndescription: Quick web scan\n\ninclude:\n  - iis-shortnames\n\nflags:\n  - web-basic\n\n\n\nweb-thorough.yml\ndescription: Aggressive web scan\n\ninclude:\n  # include the web-basic preset\n  - web-basic\n\nflags:\n  - web-thorough\n\n\n5) Everything Everywhere All at Once\n# everything everywhere all at once\nbbot -t evilcorp.com -p kitchen-sink --allow-deadly\n\n# roughly equivalent to:\nbbot -t evilcorp.com -p subdomain-enum cloud-enum code-enum email-enum spider web-basic paramminer dirbust-light web-screenshots --allow-deadly\n\nkitchen-sink.yml\ndescription: Everything everywhere all at once\n\ninclude:\n  - subdomain-enum\n  - cloud-enum\n  - code-enum\n  - email-enum\n  - spider\n  - web-basic\n  - paramminer\n  - dirbust-light\n  - web-screenshots\n  - baddns-intense\n\nconfig:\n  modules:\n    baddns:\n      enable_references: True\n\n\nHow it Works\nClick the graph below to explore the inner workings of BBOT.\n\nOutput Modules\n\nNeo4j\nTeams\nDiscord\nSlack\nPostgres\nMySQL\nSQLite\nSplunk\nElasticsearch\nCSV\nJSON\nHTTP\nWebsocket\n\n...and more!\nBBOT as a Python Library\nSynchronous\nfrom bbot.scanner import Scanner\n\nif __name__ == \"__main__\":\n    scan = Scanner(\"evilcorp.com\", presets=[\"subdomain-enum\"])\n    for event in scan.start():\n        print(event)\nAsynchronous\nfrom bbot.scanner import Scanner\n\nasync def main():\n    scan = Scanner(\"evilcorp.com\", presets=[\"subdomain-enum\"])\n    async for event in scan.async_start():\n        print(event.json())\n\nif __name__ == \"__main__\":\n    import asyncio\n    asyncio.run(main())\n\nSEE: This Nefarious Discord Bot\nA BBOT Discord Bot that responds to the /scan command. Scan the internet from the comfort of your discord server!\n\n\nFeature Overview\n\nSupport for Multiple Targets\nWeb Screenshots\nSuite of Offensive Web Modules\nNLP-powered Subdomain Mutations\nNative Output to Neo4j (and more)\nAutomatic dependency install with Ansible\nSearch entire attack surface with custom YARA rules\nPython API + Developer Documentation\n\nTargets\nBBOT accepts an unlimited number of targets via -t. You can specify targets either directly on the command line or in files (or both!):\nbbot -t evilcorp.com evilcorp.org 1.2.3.0/24 -p subdomain-enum\nTargets can be any of the following:\n\nDNS Name (evilcorp.com)\nIP Address (1.2.3.4)\nIP Range (1.2.3.0/24)\nOpen TCP Port (192.168.0.1:80)\nURL (https://www.evilcorp.com)\nEmail Address (bob@evilcorp.com)\nOrganization (ORG:evilcorp)\nUsername (USER:bobsmith)\nFilesystem (FILESYSTEM:/tmp/asdf)\nMobile App (MOBILE_APP:https://play.google.com/store/apps/details?id=com.evilcorp.app)\n\nFor more information, see Targets. To learn how BBOT handles scope, see Scope.\nAPI Keys\nSimilar to Amass or Subfinder, BBOT supports API keys for various third-party services such as SecurityTrails, etc.\nThe standard way to do this is to enter your API keys in ~/.config/bbot/bbot.yml. Note that multiple API keys are allowed:\nmodules:\n  shodan_dns:\n    api_key: 4f41243847da693a4f356c0486114bc6\n  c99:\n    # multiple API keys\n    api_key:\n      - 21a270d5f59c9b05813a72bb41707266\n      - ea8f243d9885cf8ce9876a580224fd3c\n      - 5bc6ed268ab6488270e496d3183a1a27\n  virustotal:\n    api_key: dd5f0eee2e4a99b71a939bded450b246\n  securitytrails:\n    api_key: d9a05c3fd9a514497713c54b4455d0b0\nIf you like, you can also specify them on the command line:\nbbot -c modules.virustotal.api_key=dd5f0eee2e4a99b71a939bded450b246\nFor details, see Configuration.\nComplete Lists of Modules, Flags, etc.\n\nComplete list of Modules.\nComplete list of Flags.\nComplete list of Presets.\n\nComplete list of Global Config Options.\nComplete list of Module Config Options.\n\n\n\nDocumentation\n\nUser Manual\n\nBasics\n\nGetting Started\nHow it Works\nComparison to Other Tools\n\n\nScanning\n\nScanning Overview\nPresets\n\nOverview\nList of Presets\n\n\nEvents\nOutput\nTips and Tricks\nAdvanced Usage\nConfiguration\n\n\nModules\n\nList of Modules\nNuclei\nCustom YARA Rules\n\n\nMisc\n\nContribution\nRelease History\nTroubleshooting\n\n\n\n\nDeveloper Manual\n\nDevelopment Overview\nSetting Up a Dev Environment\nBBOT Internal Architecture\nHow to Write a BBOT Module\nUnit Tests\nDiscord Bot Example\nCode Reference\n\nScanner\nPresets\nEvent\nTarget\nBaseModule\nBBOTCore\nEngine\nHelpers\n\nOverview\nCommand\nDNS\nInteractsh\nMiscellaneous\nWeb\nWord Cloud\n\n\n\n\n\n\n\nContribution\nSome of the best BBOT modules were written by the community. BBOT is being constantly improved; every day it grows more powerful!\nWe welcome contributions. Not just code, but ideas too! If you have an idea for a new feature, please let us know in Discussions. If you want to get your hands dirty, see Contribution. There you can find setup instructions and a simple tutorial on how to write a BBOT module. We also have extensive Developer Documentation.\nThanks to these amazing people for contributing to BBOT! ❤️\n\n\n\n\n\nSpecial thanks to:\n\n@TheTechromancer for creating BBOT\n@liquidsec for his extensive work on BBOT's web hacking features, including badsecrets and baddns\nSteve Micallef (@smicallef) for creating Spiderfoot\n@kerrymilan for his Neo4j and Ansible expertise\n@domwhewell-sage for his family of badass code-looting modules\n@aconite33 and @amiremami for their ruthless testing\nAleksei Kornev (@alekseiko) for granting us ownership of the bbot Pypi repository <3",
      "languages": {
        "python": 1,
        "Python": 1
      },
      "topics": [
        "MySQL",
        "Python",
        "Docker"
      ],
      "stars": 0,
      "forks": 0,
      "last_updated": "2025-02-22T13:53:41.034595"
    },
    {
      "owner": "confident-ai",
      "name": "deepeval",
      "url": "https://github.com/confident-ai/deepeval",
      "description": "The LLM Evaluation Framework",
      "readme_content": "The LLM Evaluation Framework\n\n\n\n\n\n\n\n\nDocumentation |\n        Metrics and Features |\n        Getting Started |\n        Integrations |\n        DeepEval Platform\n\n\n\n\n\n\n\n\n\n\n\n\n\nDeepEval is a simple-to-use, open-source LLM evaluation framework, for evaluating and testing large-language model systems. It is similar to Pytest but specialized for unit testing LLM outputs. DeepEval incorporates the latest research to evaluate LLM outputs based on metrics such as G-Eval, hallucination, answer relevancy, RAGAS, etc., which uses LLMs and various other NLP models that runs locally on your machine for evaluation.\nWhether your application is implemented via RAG or fine-tuning, LangChain or LlamaIndex, DeepEval has you covered. With it, you can easily determine the optimal hyperparameters to improve your RAG pipeline, prevent prompt drifting, or even transition from OpenAI to hosting your own Llama3 with confidence.\nImportantNeed a place for your DeepEval testing data to live 🏡❤️? Sign up to the DeepEval platform to compare iterations of your LLM app, generate & share testing reports, and more.\n\n\n\nWant to talk LLM evaluation, need help picking metrics, or just to say hi? Come join our discord.\n\n\n🔥 Metrics and Features\n\n🥳 You can now share DeepEval's test results on the cloud directly on Confident AI's infrastructure\n\n\nLarge variety of ready-to-use LLM evaluation metrics (all with explanations) powered by ANY LLM of your choice, statistical methods, or NLP models that runs locally on your machine:\n\nG-Eval\nDAG (deep acyclic graph)\nRAG metrics:\n\nAnswer Relevancy\nFaithfulness\nContextual Recall\nContextual Precision\nContextual Relevancy\nRAGAS\n\n\nAgentic metrics:\n\nTask Completion\nTool Correctness\n\n\nOthers:\n\nHallucination\nSummarization\nBias\nToxicity\n\n\nConversational metrics:\n\nKnowledge Retention\nConversation Completeness\nConversation Relevancy\nRole Adherence\n\n\netc.\n\n\nBuild your own custom metrics that are automatically integrated with DeepEval's ecosystem.\nGenerate synthetic datasets for evaluation.\nIntegrates seamlessly with ANY CI/CD environment.\nRed team your LLM application for 40+ safety vulnerabilities in a few lines of code, including:\n\nToxicity\nBias\nSQL Injection\netc., using advanced 10+ attack enhancement strategies such as prompt injections.\n\n\nEasily benchmark ANY LLM on popular LLM benchmarks in under 10 lines of code., which includes:\n\nMMLU\nHellaSwag\nDROP\nBIG-Bench Hard\nTruthfulQA\nHumanEval\nGSM8K\n\n\n100% integrated with Confident AI for the full evaluation lifecycle:\n\nCurate/annotate evaluation datasets on the cloud\nBenchmark LLM app using dataset, and compare with previous iterations to experiment which models/prompts works best\nFine-tune metrics for custom results\nDebug evaluation results via LLM traces\nMonitor & evaluate LLM responses in product to improve datasets with real-world data\nRepeat until perfection\n\n\n\nNoteConfident AI is the DeepEval platform. Create an account here.\n\n\n🔌 Integrations\n\n🦄 LlamaIndex, to unit test RAG applications in CI/CD\n🤗 Hugging Face, to enable real-time evaluations during LLM fine-tuning\n\n\n🚀 QuickStart\nLet's pretend your LLM application is a RAG based customer support chatbot; here's how DeepEval can help test what you've built.\nInstallation\npip install -U deepeval\n\nCreate an account (highly recommended)\nUsing the deepeval platform will allow you to generate sharable testing reports on the cloud. It is free, takes no additional code to setup, and we highly recommend giving it a try.\nTo login, run:\ndeepeval login\n\nFollow the instructions in the CLI to create an account, copy your API key, and paste it into the CLI. All test cases will automatically be logged (find more information on data privacy here).\nWriting your first test case\nCreate a test file:\ntouch test_chatbot.py\nOpen test_chatbot.py and write your first test case using DeepEval:\nimport pytest\nfrom deepeval import assert_test\nfrom deepeval.metrics import AnswerRelevancyMetric\nfrom deepeval.test_case import LLMTestCase\n\ndef test_case():\n    correctness_metric = GEval(\n        name=\"Correctness\",\n        criteria=\"Determine if the 'actual output' is correct based on the 'expected output'.\",\n        evaluation_params=[LLMTestCaseParams.ACTUAL_OUTPUT, LLMTestCaseParams.EXPECTED_OUTPUT],\n        threshold=0.5\n    )\n    test_case = LLMTestCase(\n        input=\"What if these shoes don't fit?\",\n        # Replace this with the actual output from your LLM application\n        actual_output=\"We offer a 30-day full refund at no extra costs.\",\n        retrieval_context=[\"All customers are eligible for a 30 day full refund at no extra costs.\"]\n    )\n    assert_test(test_case, [correctness_metric])\nSet your OPENAI_API_KEY as an environment variable (you can also evaluate using your own custom model, for more details visit this part of our docs):\nexport OPENAI_API_KEY=\"...\"\n\nAnd finally, run test_chatbot.py in the CLI:\ndeepeval test run test_chatbot.py\n\nCongratulations! Your test case should have passed ✅ Let's breakdown what happened.\n\nThe variable input mimics a user input, and actual_output is a placeholder for what your application's supposed to output based on this input.\nThe variable expected_output represents the ideal answer for a given input, and GEval is a research-backed metric provided by deepeval for you to evaluate your LLM output's on any custom custom with human-like accuracy.\nIn this example, the metric criteria is correctness of the actual_output based on the provided expected_output.\nAll metric scores range from 0 - 1, which the threshold=0.5 threshold ultimately determines if your test have passed or not.\n\nRead our documentation for more information on how to use additional metrics, create your own custom metrics, and tutorials on how to integrate with other tools like LangChain and LlamaIndex.\n\nEvaluating Without Pytest Integration\nAlternatively, you can evaluate without Pytest, which is more suited for a notebook environment.\nfrom deepeval import evaluate\nfrom deepeval.metrics import AnswerRelevancyMetric\nfrom deepeval.test_case import LLMTestCase\n\nanswer_relevancy_metric = AnswerRelevancyMetric(threshold=0.7)\ntest_case = LLMTestCase(\n    input=\"What if these shoes don't fit?\",\n    # Replace this with the actual output from your LLM application\n    actual_output=\"We offer a 30-day full refund at no extra costs.\",\n    retrieval_context=[\"All customers are eligible for a 30 day full refund at no extra costs.\"]\n)\nevaluate([test_case], [answer_relevancy_metric])\nUsing Standalone Metrics\nDeepEval is extremely modular, making it easy for anyone to use any of our metrics. Continuing from the previous example:\nfrom deepeval.metrics import AnswerRelevancyMetric\nfrom deepeval.test_case import LLMTestCase\n\nanswer_relevancy_metric = AnswerRelevancyMetric(threshold=0.7)\ntest_case = LLMTestCase(\n    input=\"What if these shoes don't fit?\",\n    # Replace this with the actual output from your LLM application\n    actual_output=\"We offer a 30-day full refund at no extra costs.\",\n    retrieval_context=[\"All customers are eligible for a 30 day full refund at no extra costs.\"]\n)\n\nanswer_relevancy_metric.measure(test_case)\nprint(answer_relevancy_metric.score)\n# All metrics also offer an explanation\nprint(answer_relevancy_metric.reason)\nNote that some metrics are for RAG pipelines, while others are for fine-tuning. Make sure to use our docs to pick the right one for your use case.\nEvaluating a Dataset / Test Cases in Bulk\nIn DeepEval, a dataset is simply a collection of test cases. Here is how you can evaluate these in bulk:\nimport pytest\nfrom deepeval import assert_test\nfrom deepeval.metrics import HallucinationMetric, AnswerRelevancyMetric\nfrom deepeval.test_case import LLMTestCase\nfrom deepeval.dataset import EvaluationDataset\n\nfirst_test_case = LLMTestCase(input=\"...\", actual_output=\"...\", context=[\"...\"])\nsecond_test_case = LLMTestCase(input=\"...\", actual_output=\"...\", context=[\"...\"])\n\ndataset = EvaluationDataset(test_cases=[first_test_case, second_test_case])\n\n@pytest.mark.parametrize(\n    \"test_case\",\n    dataset,\n)\ndef test_customer_chatbot(test_case: LLMTestCase):\n    hallucination_metric = HallucinationMetric(threshold=0.3)\n    answer_relevancy_metric = AnswerRelevancyMetric(threshold=0.5)\n    assert_test(test_case, [hallucination_metric, answer_relevancy_metric])\n# Run this in the CLI, you can also add an optional -n flag to run tests in parallel\ndeepeval test run test_<filename>.py -n 4\n\nAlternatively, although we recommend using deepeval test run, you can evaluate a dataset/test cases without using our Pytest integration:\nfrom deepeval import evaluate\n...\n\nevaluate(dataset, [answer_relevancy_metric])\n# or\ndataset.evaluate([answer_relevancy_metric])\nLLM Evaluation With Confident AI\nThe correct LLM evaluation lifecycle is only achievable with the DeepEval platform. It allows you to:\n\nCurate/annotate evaluation datasets on the cloud\nBenchmark LLM app using dataset, and compare with previous iterations to experiment which models/prompts works best\nFine-tune metrics for custom results\nDebug evaluation results via LLM traces\nMonitor & evaluate LLM responses in product to improve datasets with real-world data\nRepeat until perfection\n\nEverything on Confident AI, including how to use Confident is available here.\nTo begin, login from the CLI:\ndeepeval login\nFollow the instructions to log in, create your account, and paste your API key into the CLI.\nNow, run your test file again:\ndeepeval test run test_chatbot.py\nYou should see a link displayed in the CLI once the test has finished running. Paste it into your browser to view the results!\n\n\nContributing\nPlease read CONTRIBUTING.md for details on our code of conduct, and the process for submitting pull requests to us.\n\nRoadmap\nFeatures:\n\n Integration with Confident AI\n Implement G-Eval\n Implement RAG metrics\n Implement Conversational metrics\n Evaluation Dataset Creation\n Red-Teaming\n DAG custom metrics\n Guardrails\n\n\nAuthors\nBuilt by the founders of Confident AI. Contact jeffreyip@confident-ai.com for all enquiries.\n\nLicense\nDeepEval is licensed under Apache 2.0 - see the LICENSE.md file for details.",
      "languages": {
        "SQL": 1
      },
      "topics": [
        "SQL"
      ],
      "stars": 0,
      "forks": 0,
      "last_updated": "2025-02-22T13:53:41.772118"
    }
  ],
  "user_profiles": {
    "parulsri1616": {
      "username": "parulsri1616",
      "bio": "",
      "readme_content": "",
      "repositories": [
        "rock_paper_sci",
        "Guessing-game_Python",
        "Heartb___"
      ],
      "top_languages": {
        "python": 1,
        "Python": 1
      },
      "top_topics": {
        "Python": 1
      },
      "last_updated": "2025-02-22T13:53:32.154775"
    }
  }
}